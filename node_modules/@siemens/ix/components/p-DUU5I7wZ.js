import { h } from './p-D-__gyet.js';
import { a as a11yBoolean } from './p-Bb7pDeaQ.js';
import { s as shouldSuppressInternalValidation } from './p-Dq_H2flK.js';
import { c as createMutationObserver } from './p-CX81WQtk.js';
import { a as convertToRemString } from './p-JJddxCCh.js';
import { a as animate } from './p-DhE1t8Qh.js';
import { A as Animation } from './p-C5MWUgDN.js';

/*
 * SPDX-FileCopyrightText: 2024 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function shakeInput(input) {
    const xMax = 5;
    animate(input, {
        duration: Animation.defaultTime,
        easing: 'easeInOutSine',
        loop: 2,
        translateX: [
            {
                value: xMax * -1,
            },
            {
                value: xMax,
            },
            {
                value: xMax / -2,
            },
            {
                value: xMax / 2,
            },
            {
                value: 0,
            },
        ],
    });
}

/*
 * SPDX-FileCopyrightText: 2024 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function mapValidationResult(ref, result) {
    ref.isInvalid = result.isInvalid || result.isInvalidByRequired;
    ref.isValid = result.isValid;
    ref.isInfo = result.isInfo;
    ref.isWarning = result.isWarning;
}
function checkAllowedKeys(comp, event) {
    if (comp.allowedCharactersPattern) {
        const regex = new RegExp(comp.allowedCharactersPattern);
        if (!regex.test(event.key)) {
            event.preventDefault();
            shakeInput(comp.inputRef.current);
        }
    }
}
async function checkInternalValidity(comp, input) {
    const validityState = input.validity;
    const currentValidityState = !comp.hostElement.classList.contains('ix-invalid--validity-invalid');
    const newValidityState = validityState.valid;
    if (currentValidityState !== newValidityState) {
        const eventResult = comp.validityStateChange.emit(validityState);
        if (eventResult.defaultPrevented) {
            return;
        }
    }
    if (comp.value === null || comp.value === undefined) {
        return;
    }
    const skipValidation = await shouldSuppressInternalValidation(comp);
    if (skipValidation) {
        return;
    }
    const { valid } = validityState;
    comp.hostElement.classList.toggle('ix-invalid--validity-invalid', !valid);
}
function onInputBlur(comp, input) {
    comp.ixBlur.emit();
    if (!input) {
        throw new Error('Input element is not available');
    }
    input.setAttribute('data-ix-touched', 'true');
    checkInternalValidity(comp, input);
}
function applyPaddingEnd(inputElement, width, options) {
    var _a;
    if (!inputElement) {
        return;
    }
    const remInPixels = 16;
    const padding = convertToRemString(width + remInPixels / 2);
    if (options.slotEnd) {
        inputElement.style.paddingRight = `calc(${padding} + ${(_a = options.additionalPaddingRight) !== null && _a !== void 0 ? _a : '0rem'})`;
    }
    else {
        inputElement.style.paddingLeft = padding;
    }
}
function adjustPaddingForStartAndEnd(startElement, endElement, inputElement) {
    requestAnimationFrame(() => {
        requestAnimationFrame(() => {
            if (startElement) {
                const startBoundingRect = startElement.getBoundingClientRect();
                if (startBoundingRect) {
                    applyPaddingEnd(inputElement, startBoundingRect.width, {
                        slotEnd: false,
                    });
                }
            }
            if (endElement) {
                const endBoundingRect = endElement.getBoundingClientRect();
                if (endBoundingRect) {
                    applyPaddingEnd(inputElement, endBoundingRect.width, {
                        slotEnd: true,
                    });
                }
            }
        });
    });
}
function getAriaAttributesForInput(component) {
    const inputAria = {
        'aria-invalid': `${a11yBoolean(component.isInvalid)}`,
        'aria-required': `${a11yBoolean(component.required)}`,
    };
    if (component.isInvalid && component.invalidText) {
        inputAria['aria-errormessage'] = component.invalidText;
    }
    return inputAria;
}
const addDisposableChangesAndVisibilityObservers = (element, callback) => {
    const intersectionObserver = observeElementUntilVisible(element, callback);
    const mutationObserver = createMutationObserver(callback);
    mutationObserver.observe(element, {
        subtree: true,
        attributes: true,
    });
    return () => {
        intersectionObserver.disconnect();
        mutationObserver.disconnect();
    };
};
function observeElementUntilVisible(hostElement, updateCallback) {
    const intersectionObserver = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                updateCallback();
            }
        });
    });
    intersectionObserver.observe(hostElement);
    return intersectionObserver;
}
function handleSubmitOnEnterKeydown(event, suppressSubmitOnEnter, form) {
    if (suppressSubmitOnEnter || event.key !== 'Enter' || !form) {
        return;
    }
    event.preventDefault();
    const submitButton = form.querySelector('button[type="submit"], ix-button[type="submit"]');
    if (submitButton) {
        form.requestSubmit(submitButton);
    }
    if (form.length === 1) {
        form.requestSubmit();
    }
}

/*
 * SPDX-FileCopyrightText: 2024 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function TextareaElement(props) {
    return (h("textarea", Object.assign({ readOnly: props.readonly, disabled: props.disabled, maxLength: props.maxLength, minLength: props.minLength, cols: props.textareaCols, rows: props.textareaRows, ref: props.textAreaRef, class: {
            'is-invalid': props.isInvalid,
        }, required: props.required, value: props.value, placeholder: props.placeholder, onInput: (inputEvent) => {
            const target = inputEvent.target;
            props.updateFormInternalValue(target.value);
            props.valueChange(target.value);
        }, onBlur: () => props.onBlur(), style: {
            resize: props.resizeBehavior,
            height: props.textareaHeight,
            width: props.textareaWidth,
        } }, props.ariaAttributes)));
}
function InputElement(props) {
    return (h("input", Object.assign({ id: props.id, autoComplete: "off", readOnly: props.readonly, disabled: props.disabled, step: props.step, min: props.min, max: props.max, maxLength: props.maxLength ? Number(props.maxLength) : undefined, minLength: props.minLength ? Number(props.minLength) : undefined, ref: props.inputRef, pattern: props.pattern, type: props.type, class: {
            'is-invalid': props.isInvalid,
        }, style: {
            textAlign: props.textAlignment,
        }, required: props.required, value: props.value, placeholder: props.placeholder, onKeyPress: (event) => props.onKeyPress(event), onKeyDown: (e) => {
            var _a;
            (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            handleSubmitOnEnterKeydown(e, !!props.suppressSubmitOnEnter, props.form);
        } }, {
        onBeforeInput: (event) => { var _a; return (_a = props.onBeforeInput) === null || _a === void 0 ? void 0 : _a.call(props, event); },
    }, { onPaste: (event) => { var _a; return (_a = props.onPaste) === null || _a === void 0 ? void 0 : _a.call(props, event); }, onInput: (inputEvent) => {
            const target = inputEvent.target;
            props.updateFormInternalValue(target.value);
            props.valueChange(target.value);
        }, onBlur: () => props.onBlur() }, props.ariaAttributes)));
}
const SlotEnd = (props, children) => {
    return (h("div", { class: "end-container", ref: props.slotEndRef }, h("slot", { name: "end", onSlotchange: props.onSlotChange }), children));
};
const SlotStart = (props) => {
    return (h("div", { class: "start-container", ref: props.slotStartRef }, h("slot", { name: "start", onSlotchange: props.onSlotChange })));
};

export { InputElement as I, SlotEnd as S, TextareaElement as T, addDisposableChangesAndVisibilityObservers as a, adjustPaddingForStartAndEnd as b, SlotStart as c, checkAllowedKeys as d, checkInternalValidity as e, getAriaAttributesForInput as g, handleSubmitOnEnterKeydown as h, mapValidationResult as m, onInputBlur as o };
//# sourceMappingURL=p-DUU5I7wZ.js.map

//# sourceMappingURL=p-DUU5I7wZ.js.map
/*
 * SPDX-FileCopyrightText: 2024 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { h } from "@stencil/core";
import { handleSubmitOnEnterKeydown } from "./input.util";
export function TextareaElement(props) {
    return (h("textarea", Object.assign({ readOnly: props.readonly, disabled: props.disabled, maxLength: props.maxLength, minLength: props.minLength, cols: props.textareaCols, rows: props.textareaRows, ref: props.textAreaRef, class: {
            'is-invalid': props.isInvalid,
        }, required: props.required, value: props.value, placeholder: props.placeholder, onInput: (inputEvent) => {
            const target = inputEvent.target;
            props.updateFormInternalValue(target.value);
            props.valueChange(target.value);
        }, onBlur: () => props.onBlur(), style: {
            resize: props.resizeBehavior,
            height: props.textareaHeight,
            width: props.textareaWidth,
        } }, props.ariaAttributes)));
}
export function InputElement(props) {
    return (h("input", Object.assign({ id: props.id, autoComplete: "off", readOnly: props.readonly, disabled: props.disabled, step: props.step, min: props.min, max: props.max, maxLength: props.maxLength ? Number(props.maxLength) : undefined, minLength: props.minLength ? Number(props.minLength) : undefined, ref: props.inputRef, pattern: props.pattern, type: props.type, class: {
            'is-invalid': props.isInvalid,
        }, style: {
            textAlign: props.textAlignment,
        }, required: props.required, value: props.value, placeholder: props.placeholder, onKeyPress: (event) => props.onKeyPress(event), onKeyDown: (e) => {
            var _a;
            (_a = props.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            handleSubmitOnEnterKeydown(e, !!props.suppressSubmitOnEnter, props.form);
        } }, {
        onBeforeInput: (event) => { var _a; return (_a = props.onBeforeInput) === null || _a === void 0 ? void 0 : _a.call(props, event); },
    }, { onPaste: (event) => { var _a; return (_a = props.onPaste) === null || _a === void 0 ? void 0 : _a.call(props, event); }, onInput: (inputEvent) => {
            const target = inputEvent.target;
            props.updateFormInternalValue(target.value);
            props.valueChange(target.value);
        }, onBlur: () => props.onBlur() }, props.ariaAttributes)));
}
export const SlotEnd = (props, children) => {
    return (h("div", { class: "end-container", ref: props.slotEndRef }, h("slot", { name: "end", onSlotchange: props.onSlotChange }), children));
};
export const SlotStart = (props) => {
    return (h("div", { class: "start-container", ref: props.slotStartRef }, h("slot", { name: "start", onSlotchange: props.onSlotChange })));
};
//# sourceMappingURL=input.fc.js.map

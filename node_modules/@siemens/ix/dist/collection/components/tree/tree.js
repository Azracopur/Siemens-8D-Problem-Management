/*
 * SPDX-FileCopyrightText: 2024 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { h, Host, } from "@stencil/core";
import { dropdownController } from "../dropdown/dropdown-controller";
import { renderDefaultItem } from "../tree-item/default-tree-item";
import { VirtualList } from "./../utils/lazy-list";
import { defaultRefreshTreeOptions } from "./tree.types";
export class Tree {
    constructor() {
        /**
         * Initial root element will not be rendered
         */
        this.root = 'root';
        /**
         * Tree model
         */
        this.model = {};
        /**
         * Selection and collapsed state management
         */
        this.context = {};
        this.updates = new Map();
        this.hasFirstRender = false;
        this.dirtyItems = new Set();
    }
    updatePadding(element, item) {
        element.style.paddingLeft = item.level + 'rem';
    }
    getVirtualizerOptions(refreshTreeOptions) {
        const list = this.buildTreeList(this.model[this.root]);
        return {
            width: '100%',
            height: '100%',
            itemHeight: 32,
            total: list.length,
            generate: (index) => {
                const item = list[index];
                const renderedTreeItem = this.hostElement.querySelector(`[data-tree-node-id="${item.id}"]`);
                const context = this.getContext(item.id);
                /**
                 * Return only the existing item if it is already rendered
                 */
                if (renderedTreeItem && refreshTreeOptions.force === false) {
                    renderedTreeItem.hasChildren = item.hasChildren;
                    renderedTreeItem.context = Object.assign({}, context);
                    let forceRerender = this.dirtyItems.has(item.id);
                    if (this.updates.has(item.id)) {
                        const doUpdate = this.updates.get(item.id);
                        if (doUpdate) {
                            const updateRequestedRerender = doUpdate(item, Object.assign({}, this.context));
                            if (typeof updateRequestedRerender === 'boolean') {
                                forceRerender = updateRequestedRerender;
                            }
                        }
                    }
                    this.updatePadding(renderedTreeItem, item);
                    if (!forceRerender) {
                        return renderedTreeItem;
                    }
                }
                const update = (callback) => {
                    this.updates.set(item.id, callback);
                };
                let innerElement = null;
                if (this.renderItem) {
                    innerElement = this.renderItem(index, item, list, Object.assign({}, this.context), update);
                }
                if (innerElement === null) {
                    innerElement = renderDefaultItem(item, context, update);
                }
                const el = innerElement;
                el.setAttribute('data-tree-node-id', item.id);
                el.style.paddingRight = '1rem';
                this.updatePadding(el, item);
                this.dirtyItems.delete(item.id);
                return el;
            },
        };
    }
    setContext(id, context) {
        this.context = Object.assign(Object.assign({}, this.context), { [id]: context });
        this.contextChange.emit(this.context);
    }
    getContext(id) {
        if (!this.context) {
            return {
                isExpanded: false,
                isSelected: false,
            };
        }
        if (!this.context[id]) {
            this.context[id] = {
                isExpanded: false,
                isSelected: false,
            };
        }
        return this.context[id];
    }
    buildTreeList(root, level = 0) {
        const itemList = [];
        if (root === null || root === void 0 ? void 0 : root.hasChildren) {
            const newLevel = level + 1;
            root.children.forEach((id) => {
                const item = this.model[id];
                const context = this.getContext(id);
                itemList.push(Object.assign(Object.assign({}, item), { level }));
                if (item.hasChildren && context.isExpanded) {
                    itemList.push(...this.buildTreeList(item, newLevel));
                }
            });
        }
        return itemList;
    }
    componentDidLoad() {
        this.initList();
        this.observer = new MutationObserver((records) => {
            let removed = [];
            records.forEach((record) => {
                removed = [...removed, ...Array.from(record.removedNodes)];
                record.addedNodes.forEach((an) => {
                    const index = removed.indexOf(an);
                    if (index >= 0) {
                        removed.splice(index, 1);
                    }
                });
            });
            this.nodeRemoved.emit(removed);
        });
        this.observer.observe(this.hostElement, {
            childList: true,
        });
    }
    componentWillRender() {
        this.hasFirstRender = true;
        if (this.isListInitialized()) {
            this.refreshTree();
        }
        else {
            this.initList();
        }
    }
    connectedCallback() {
        if (this.hasFirstRender) {
            this.initList();
        }
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this.hyperlist) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.observer) === null || _b === void 0 ? void 0 : _b.disconnect();
    }
    onModelChange() {
        if (this.hasFirstRender && !this.isListInitialized()) {
            this.initList();
        }
    }
    /**
     * Mark items as dirty.
     * This will force the list to re-render the items with the given ids.
     */
    async markItemsAsDirty(ids) {
        ids.forEach((id) => this.dirtyItems.add(id));
    }
    isListInitialized() {
        var _a;
        //@ts-ignore
        const itemPositions = (_a = this.hyperlist) === null || _a === void 0 ? void 0 : _a._itemPositions;
        return (itemPositions !== undefined &&
            itemPositions.length &&
            !(itemPositions === null || itemPositions === void 0 ? void 0 : itemPositions.some((item) => item === undefined || Number.isNaN(item))));
    }
    /**
     * Refresh the list.
     * This will re-render the list with the current model and context.
     */
    async refreshTree(options = defaultRefreshTreeOptions) {
        if (this.hyperlist) {
            this.hyperlist.refresh(this.hostElement, this.getVirtualizerOptions(options));
        }
    }
    initList() {
        var _a;
        if (!this.model) {
            return;
        }
        (_a = this.hyperlist) === null || _a === void 0 ? void 0 : _a.destroy();
        const config = this.getVirtualizerOptions(defaultRefreshTreeOptions);
        this.hyperlist = new VirtualList(this.hostElement, config);
    }
    onToggle(event) {
        const { target } = event;
        event.preventDefault();
        event.stopPropagation();
        if (!(target instanceof HTMLElement)) {
            return;
        }
        const id = target.getAttribute('data-tree-node-id');
        if (!id) {
            return;
        }
        const item = this.model[id];
        if (!item.hasChildren) {
            return;
        }
        const context = this.getContext(id);
        context.isExpanded = !context.isExpanded;
        this.nodeToggled.emit({ id, isExpanded: context.isExpanded });
        this.setContext(id, context);
    }
    onTreeItemClick(event) {
        const { target } = event;
        if (!(target instanceof HTMLElement)) {
            return;
        }
        const id = target.getAttribute('data-tree-node-id');
        if (!id) {
            return;
        }
        const item = this.model[id];
        const path = event.composedPath();
        const treeIndex = path.indexOf(this.hostElement);
        const treePath = path.slice(0, treeIndex);
        const hasTrigger = dropdownController.pathIncludesTrigger(treePath);
        if (hasTrigger) {
            return;
        }
        if (!event.defaultPrevented) {
            Object.values(this.context).forEach((c) => (c.isSelected = false));
            const context = this.getContext(id);
            context.isSelected = true;
            this.setContext(id, context);
        }
        if (this.toggleOnItemClick && item.hasChildren) {
            const context = this.getContext(id);
            context.isExpanded = !context.isExpanded;
            this.nodeToggled.emit({
                id: id,
                isExpanded: context.isExpanded,
            });
            this.setContext(id, context);
        }
        this.nodeClicked.emit(id);
    }
    render() {
        return (h(Host, { key: 'ca0d582877d3b2877a1090cc0aeb40f38617cef9', onClick: (event) => this.onTreeItemClick(event) }, h("slot", { key: '2d8f21165234243b6d2e2f7c99696fc7343d79f2' })));
    }
    static get is() { return "ix-tree"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["tree.css"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["tree.css"]
        };
    }
    static get properties() {
        return {
            "root": {
                "type": "string",
                "attribute": "root",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Initial root element will not be rendered"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'root'"
            },
            "model": {
                "type": "unknown",
                "attribute": "model",
                "mutable": false,
                "complexType": {
                    "original": "TreeModel<any>",
                    "resolved": "{ [x: string]: TreeItem<any>; }",
                    "references": {
                        "TreeModel": {
                            "location": "import",
                            "path": "./tree-model",
                            "id": "src/components/tree/tree-model.ts::TreeModel"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Tree model"
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "renderItem": {
                "type": "unknown",
                "attribute": "render-item",
                "mutable": false,
                "complexType": {
                    "original": "<T = any>(\n    index: number,\n    data: T,\n    dataList: Array<T>,\n    context: TreeContext,\n    update: (callback: UpdateCallback) => void\n  ) => HTMLElement",
                    "resolved": "(<T = any>(index: number, data: T, dataList: T[], context: TreeContext, update: (callback: UpdateCallback) => void) => HTMLElement) | undefined",
                    "references": {
                        "T": {
                            "location": "global",
                            "id": "global::T"
                        },
                        "Array": {
                            "location": "global",
                            "id": "global::Array"
                        },
                        "TreeContext": {
                            "location": "import",
                            "path": "./tree-model",
                            "id": "src/components/tree/tree-model.ts::TreeContext"
                        },
                        "UpdateCallback": {
                            "location": "import",
                            "path": "./tree-model",
                            "id": "src/components/tree/tree-model.ts::UpdateCallback"
                        },
                        "HTMLElement": {
                            "location": "global",
                            "id": "global::HTMLElement"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Render function of tree items"
                },
                "getter": false,
                "setter": false
            },
            "context": {
                "type": "unknown",
                "attribute": "context",
                "mutable": true,
                "complexType": {
                    "original": "TreeContext",
                    "resolved": "{ [x: string]: TreeItemContext; }",
                    "references": {
                        "TreeContext": {
                            "location": "import",
                            "path": "./tree-model",
                            "id": "src/components/tree/tree-model.ts::TreeContext"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Selection and collapsed state management"
                },
                "getter": false,
                "setter": false,
                "defaultValue": "{}"
            },
            "toggleOnItemClick": {
                "type": "boolean",
                "attribute": "toggle-on-item-click",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.0.0"
                        }],
                    "text": "Enable to toggle items by click on the item"
                },
                "getter": false,
                "setter": false,
                "reflect": false
            }
        };
    }
    static get events() {
        return [{
                "method": "contextChange",
                "name": "contextChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Context changed"
                },
                "complexType": {
                    "original": "TreeContext",
                    "resolved": "{ [x: string]: TreeItemContext; }",
                    "references": {
                        "TreeContext": {
                            "location": "import",
                            "path": "./tree-model",
                            "id": "src/components/tree/tree-model.ts::TreeContext"
                        }
                    }
                }
            }, {
                "method": "nodeToggled",
                "name": "nodeToggled",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Node toggled event"
                },
                "complexType": {
                    "original": "{ id: string; isExpanded: boolean }",
                    "resolved": "{ id: string; isExpanded: boolean; }",
                    "references": {}
                }
            }, {
                "method": "nodeClicked",
                "name": "nodeClicked",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Node clicked event"
                },
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                }
            }, {
                "method": "nodeRemoved",
                "name": "nodeRemoved",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emits removed nodes"
                },
                "complexType": {
                    "original": "any",
                    "resolved": "any",
                    "references": {}
                }
            }];
    }
    static get methods() {
        return {
            "markItemsAsDirty": {
                "complexType": {
                    "signature": "(ids: string[]) => Promise<void>",
                    "parameters": [{
                            "name": "ids",
                            "type": "string[]",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Mark items as dirty.\nThis will force the list to re-render the items with the given ids.",
                    "tags": []
                }
            },
            "refreshTree": {
                "complexType": {
                    "signature": "(options?: RefreshTreeOptions) => Promise<void>",
                    "parameters": [{
                            "name": "options",
                            "type": "{ force?: boolean | undefined; }",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "RefreshTreeOptions": {
                            "location": "import",
                            "path": "./tree.types",
                            "id": "src/components/tree/tree.types.ts::RefreshTreeOptions"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "Refresh the list.\nThis will re-render the list with the current model and context.",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "hostElement"; }
    static get watchers() {
        return [{
                "propName": "model",
                "methodName": "onModelChange"
            }];
    }
    static get listeners() {
        return [{
                "name": "toggle",
                "method": "onToggle",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=tree.js.map

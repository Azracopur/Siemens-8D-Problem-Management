'use strict';

var index = require('./index-C8Xo8L1k.js');
var breakpoints = require('./breakpoints-C5ZrUCbZ.js');
var index$1 = require('./index-Dyz3z1FD.js');
var datetime = require('./datetime-Dvtv5O8f.js');
var listener = require('./listener-OBCpw0Y2.js');
var makeRef = require('./make-ref-BaH6_YJk.js');

const colCss = ":host{position:relative;flex-basis:0;flex-grow:1;width:100%;max-width:100%;min-height:1px;padding:calc(var(--ix-layout-grid-gutter) * 0.5)}:host *,:host *::after,:host *::before{box-sizing:border-box}:host ::-webkit-scrollbar-button{display:none}@-moz-document url-prefix(){:host *{scrollbar-color:var(--theme-scrollbar-thumb--background) var(--theme-scrollbar-track--background);scrollbar-width:thin}}:host{}:host ::-webkit-scrollbar{width:0.5rem;height:0.5rem}:host{}:host ::-webkit-scrollbar-track{border-radius:5px;background:var(--theme-scrollbar-track--background)}:host ::-webkit-scrollbar-track:hover{background:var(--theme-scrollbar-track--background--hover)}:host{}:host ::-webkit-scrollbar-thumb{border-radius:5px;background:var(--theme-scrollbar-thumb--background)}:host{}:host ::-webkit-scrollbar-thumb:hover{background:var(--theme-scrollbar-thumb--background--hover)}:host ::-webkit-scrollbar-corner{display:none}";

const Col = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
    }
    onResize() {
        index.forceUpdate(this);
    }
    getSize(breakpoint) {
        if (breakpoint === '') {
            return this.size;
        }
        if (breakpoint === 'sm') {
            return this.sizeSm;
        }
        if (breakpoint === 'md') {
            return this.sizeMd;
        }
        if (breakpoint === 'lg') {
            return this.sizeLg;
        }
    }
    getColumnSize() {
        let size;
        Col.Breakpoints.forEach((breakpoint) => {
            const isMediaQueryActive = breakpoint !== '' ? breakpoints.matchBreakpoint(breakpoint) : true;
            if (!isMediaQueryActive) {
                return;
            }
            const currentSize = this.getSize(breakpoint);
            if (currentSize) {
                size = currentSize;
            }
        });
        return size;
    }
    getColumnSizeStyling() {
        const size = this.getColumnSize();
        if (!size) {
            return;
        }
        if (size === 'auto') {
            return {
                flex: '0 0 auto',
                width: 'auto',
                'max-width': 'auto',
            };
        }
        const colSize = `calc(calc(${size} / var(--ix-layout-grid-columns)) * 100%)`;
        return {
            flex: `0 0 ${colSize}`,
            width: `${colSize}`,
            'max-width': `${colSize}`,
        };
    }
    render() {
        return (index.h(index.Host, { key: '552bf87dd4905b2cfc67dbda7c33e1edf89a9cf8', style: Object.assign({}, this.getColumnSizeStyling()) }, index.h("slot", { key: '293331e4b2de069f550f0d47e1525228e49fc159' })));
    }
};
Col.Breakpoints = ['', 'sm', 'md', 'lg'];
Col.style = colCss;

const datePickerCss = ":host{display:block;position:relative;max-width:21rem}:host *,:host *::after,:host *::before{box-sizing:border-box}:host ::-webkit-scrollbar-button{display:none}@-moz-document url-prefix(){:host *{scrollbar-color:var(--theme-scrollbar-thumb--background) var(--theme-scrollbar-track--background);scrollbar-width:thin}}:host{}:host ::-webkit-scrollbar{width:0.5rem;height:0.5rem}:host{}:host ::-webkit-scrollbar-track{border-radius:5px;background:var(--theme-scrollbar-track--background)}:host ::-webkit-scrollbar-track:hover{background:var(--theme-scrollbar-track--background--hover)}:host{}:host ::-webkit-scrollbar-thumb{border-radius:5px;background:var(--theme-scrollbar-thumb--background)}:host{}:host ::-webkit-scrollbar-thumb:hover{background:var(--theme-scrollbar-thumb--background--hover)}:host ::-webkit-scrollbar-corner{display:none}:host .header{display:flex;align-items:center;justify-content:space-between}:host .disabled-item{pointer-events:none;background-color:var(--theme-datepicker-day--background--disabled);color:var(--theme-datepicker-day--color--disabled);cursor:default}:host .selector{flex-basis:100%;display:flex;align-items:center;justify-content:center;padding:0 1rem}:host .selector .dropdown{color:var(--theme-menu-item--color);font-size:14px;line-height:20px}:host .selector .capitalize{text-transform:capitalize}:host .selector .month-dropdown-item{margin-left:4px;margin-right:4px}:host .selector .month-dropdown-item:focus-visible{outline:1px solid var(--theme-color-focus-bdr);outline-offset:var(--theme-btn--focus--outline-offset)}:host .selector .arrowYear{display:flex;position:relative;padding:0.75rem 2rem;align-items:center;cursor:pointer}:host .selector .arrowYear:hover{background-color:var(--theme-select-list-item--background--hover)}:host .selector .arrowYear.selected{background-color:var(--theme-select-list-item--background--selected)}:host .selector .arrowYear .arrowPosition{position:absolute;left:calc(1rem - 6px);top:calc(50% - 6px)}:host .selector .arrowYear .checkPosition{position:absolute;left:calc(1rem - 6px);top:calc(50% - 8px)}:host .selector .arrowYear .monthMargin{margin-left:10px}:host .wrapper{display:flex}:host .wrapper .overflow{overflow-y:scroll;max-height:250px}:host .grid{display:grid;grid-template-columns:repeat(7, 40px);grid-template-rows:repeat(7, 40px);align-items:center;justify-items:center;justify-content:center;color:var(--theme-datepicker-today--color)}:host .grid--show-week-numbers{grid-template-columns:24px repeat(7, 40px)}:host .grid .calendar-item{position:relative;display:flex;justify-content:center;align-items:center;background-color:var(--theme-datepicker-day--background);border:1px solid var(--theme-datepicker-day--background);width:40px;height:40px;cursor:pointer}:host .grid .calendar-item:focus-visible{outline:1px solid var(--theme-color-focus-bdr);box-shadow:inset 0 0 0 1px var(--theme-color-inv-contrast-text);background-color:var(--theme-datepicker-day--background--selected);border:inset 1px solid var(--theme-datepicker-day--border-color--selected);color:var(--theme-datepicker-day--color--selected);font-size:14px;line-height:20px;letter-spacing:0}:host .grid .calendar-item.today{border:1px solid var(--theme-datepicker-today--border-color)}:host .grid .calendar-item.today:hover{background-color:var(--theme-datepicker-day--background--hover)}:host .grid .calendar-item.today:active{background-color:var(--theme-datepicker-day--background--active)}:host .grid .calendar-item.today.selected{box-shadow:inset 0 0 0 1px white}:host .grid .calendar-item.today.selected:hover{background-color:var(--theme-datepicker-day--background--selected-hover)}:host .grid .calendar-item.today.selected:active{background-color:var(--theme-datepicker-day--background--selected-active)}:host .grid .calendar-item.today.selected.disabled{pointer-events:none;background-color:var(--theme-datepicker-day--background--selected-disabled);border:1px solid var(--theme-datepicker-day--background--selected-disabled);color:var(--theme-datepicker-day--color--selected-disabled)}:host .grid .calendar-item.today.range{background-color:var(--theme-datepicker-day--background--range);color:var(--theme-datepicker-day--color--range);border:1px solid var(--theme-datepicker-today--border-color--range);box-shadow:inset 0 0 0 1px white}:host .grid .calendar-item.today.range:hover{background-color:var(--theme-datepicker-day--background--range-hover);border:1px solid var(--theme-datepicker-today--border-color--range-hover)}:host .grid .calendar-item.today.range:active{background-color:var(--theme-datepicker-day--background--range-active);border:1px solid var(--theme-datepicker-today--border-color--range-active)}:host .grid .calendar-item.today.range.disabled{background-color:var(--theme-datepicker-day--background--range-disabled);color:var(--theme-datepicker-day--color--range-disabled);border:1px solid var(--theme-datepicker-today--border-color--range-disabled)}:host .grid .calendar-item.today.disabled{pointer-events:none;background-color:var(--theme-datepicker-day--background--disabled);color:var(--theme-datepicker-day--color--disabled);cursor:default}:host .grid .calendar-item:hover{background-color:var(--theme-datepicker-day--background--hover)}:host .grid .calendar-item:active{background-color:var(--theme-datepicker-day--background--active)}:host .grid .calendar-item.selected{background-color:var(--theme-datepicker-day--background--selected);color:var(--theme-datepicker-day--color--selected);border:1px solid var(--theme-datepicker-day--background--selected);font-weight:var(--theme-font-weight-bold)}:host .grid .calendar-item.selected:hover{background-color:var(--theme-datepicker-day--background--selected-hover)}:host .grid .calendar-item.selected:active{background-color:var(--theme-datepicker-day--background--selected-active)}:host .grid .calendar-item.selected.disabled{pointer-events:none;background-color:var(--theme-datepicker-day--background--selected-disabled);color:var(--theme-datepicker-day--color--selected-disabled)}:host .grid .calendar-item.range{background-color:var(--theme-datepicker-day--background--range);color:var(--theme-datepicker-day--color--range)}:host .grid .calendar-item.range:hover{background-color:var(--theme-datepicker-day--background--range-hover)}:host .grid .calendar-item.range:active{background-color:var(--theme-datepicker-day--background--range-active)}:host .grid .calendar-item.range.disabled{pointer-events:none;background-color:var(--theme-datepicker-day--background--range-disabled);color:var(--theme-datepicker-day--color--range-disabled)}:host .grid .calendar-item.disabled{pointer-events:none;background-color:var(--theme-datepicker-day--background--disabled);color:var(--theme-datepicker-day--color--disabled)}:host .grid .calendar-item.week-day{color:var(--theme-datepicker-weekday--color);font-size:var(--theme-ms-0);line-height:143%;border:none;background:none;cursor:initial}:host .grid .calendar-item.week-day .overflow{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}:host .grid .calendar-item.empty-day{border:none;background:none;cursor:initial}:host .grid .calendar-item.week-number{font-size:10px;line-height:14px;color:var(--theme-datepicker-weekday--color);border:none;background:none;cursor:initial;width:1.5rem}:host .button{display:flex;justify-content:flex-end;margin-top:1rem}:host .hidden{display:none}";

/*
 * SPDX-FileCopyrightText: 2023 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const DatePicker = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.dateChange = index.createEvent(this, "dateChange", 7);
        this.dateRangeChange = index.createEvent(this, "dateRangeChange", 7);
        this.dateSelect = index.createEvent(this, "dateSelect", 7);
        /**
         * Date format string.
         * See {@link https://moment.github.io/luxon/#/formatting?id=table-of-tokens} for all available tokens.
         */
        this.format = 'yyyy/LL/dd';
        /**
         * If true disables date range selection (from/to).
         */
        this.singleSelection = false;
        /**
         * Corner style
         */
        this.corners = 'rounded';
        /**
         * The earliest date that can be selected by the date picker.
         * If not set there will be no restriction.
         */
        this.minDate = '';
        /**
         * The latest date that can be selected by the date picker.
         * If not set there will be no restriction.
         */
        this.maxDate = '';
        /**
         * Text of date select button
         */
        this.i18nDone = 'Done';
        /**
         * The index of which day to start the week on, based on the Locale#weekdays array.
         * E.g. if the locale is en-us, weekStartIndex = 1 results in starting the week on monday.
         */
        this.weekStartIndex = 0;
        /**
         * Shows week numbers displayed on the left side of the date picker
         *
         * @since 3.0.0
         */
        this.showWeekNumbers = false;
        /** @internal */
        this.embedded = false;
        /** @internal */
        this.today = datetime.DateTime.now().toISO();
        this.selectedYear = 0;
        this.tempYear = 0;
        this.startYear = 0;
        this.endYear = 0;
        this.selectedMonth = 0;
        this.tempMonth = 0;
        this.dropdownButtonRef = makeRef.makeRef();
        this.yearContainerRef = makeRef.makeRef();
        this.firstMonthRef = makeRef.makeRef();
        this.focusedDay = 1;
        this.isDayFocus = false;
        this.monthChangedFromFocus = false;
        this.DAYS_IN_WEEK = 7;
        this.calendar = [];
    }
    watchFromPropHandler(newValue) {
        if (!newValue) {
            this.currFromDate = undefined;
            return;
        }
        const date = this.parseDateString(newValue);
        if (date) {
            this.currFromDate = date;
            this.updateSelectedYearMonth(date);
        }
    }
    watchToPropHandler(newValue) {
        if (!newValue) {
            this.currToDate = undefined;
            return;
        }
        const date = this.parseDateString(newValue);
        if (date) {
            this.currToDate = date;
            this.updateSelectedYearMonth(date);
        }
    }
    onLocaleChange() {
        this.setTranslations();
    }
    /**
     * Get the currently selected date or range. The object returned contains `from` and `to` properties.
     * The property strings are formatted according to the `format` property and not affected by the `locale` property.
     * The locale applied is always `en-US`.
     */
    async getCurrentDate() {
        var _a, _b, _c, _d;
        const _from = ((_a = this.currFromDate) === null || _a === void 0 ? void 0 : _a.isValid)
            ? (_b = this.currFromDate) === null || _b === void 0 ? void 0 : _b.toFormat(this.format)
            : undefined;
        const _to = ((_c = this.currToDate) === null || _c === void 0 ? void 0 : _c.isValid)
            ? (_d = this.currToDate) === null || _d === void 0 ? void 0 : _d.toFormat(this.format)
            : undefined;
        if (!this.singleSelection) {
            return {
                from: _from,
                to: _to,
            };
        }
        return {
            from: _from,
            to: undefined,
        };
    }
    handleKeyUp(event) {
        if (!this.isDayFocus) {
            return;
        }
        let _focusedDay = this.focusedDay;
        switch (event.key) {
            case 'ArrowLeft':
                _focusedDay--;
                break;
            case 'ArrowRight':
                _focusedDay++;
                break;
            case 'ArrowUp':
                _focusedDay = _focusedDay - 7;
                break;
            case 'ArrowDown':
                _focusedDay = _focusedDay + 7;
                break;
            default:
                return;
        }
        if (_focusedDay > this.getDaysInCurrentMonth()) {
            _focusedDay = _focusedDay - this.getDaysInCurrentMonth();
            this.changeToAdjacentMonth(1);
            this.monthChangedFromFocus = true;
        }
        else if (_focusedDay < 1) {
            this.changeToAdjacentMonth(-1);
            _focusedDay = _focusedDay + this.getDaysInCurrentMonth();
            this.monthChangedFromFocus = true;
        }
        this.focusedDay = _focusedDay;
    }
    getDaysInCurrentMonth() {
        return (datetime.DateTime.utc(this.selectedYear, this.selectedMonth + 1).daysInMonth || 0);
    }
    getDateTimeNow() {
        return datetime.DateTime.fromISO(this.today);
    }
    parseDateString(dateString) {
        const date = datetime.DateTime.fromFormat(dateString, this.format);
        if (!date.isValid) {
            console.error(date.invalidExplanation);
            return undefined;
        }
        return date;
    }
    updateSelectedYearMonth(date) {
        this.selectedYear = date.year;
        this.selectedMonth = date.month - 1;
    }
    onDayBlur() {
        this.isDayFocus = false;
    }
    onDayFocus() {
        this.isDayFocus = true;
    }
    componentWillLoad() {
        var _a, _b, _c, _d;
        this.setTranslations();
        this.currFromDate = this.from
            ? datetime.DateTime.fromFormat(this.from, this.format)
            : undefined;
        this.currToDate = this.to
            ? datetime.DateTime.fromFormat(this.to, this.format)
            : undefined;
        const year = (_b = (_a = this.currFromDate) === null || _a === void 0 ? void 0 : _a.year) !== null && _b !== void 0 ? _b : this.getDateTimeNow().year;
        this.startYear = year - 5;
        this.endYear = year + 5;
        this.selectedMonth =
            ((_d = (_c = this.currFromDate) === null || _c === void 0 ? void 0 : _c.month) !== null && _d !== void 0 ? _d : this.getDateTimeNow().month) - 1;
        this.selectedYear = year;
        this.tempMonth = this.selectedMonth;
        this.tempYear = this.selectedYear;
    }
    componentWillRender() {
        this.calculateCalendar();
    }
    componentDidRender() {
        if (!this.monthChangedFromFocus && !this.isDayFocus) {
            return;
        }
        const dayElem = this.hostElement.shadowRoot.querySelector(`[id=day-cell-${this.focusedDay}]`);
        dayElem.focus();
    }
    setTranslations() {
        this.dayNames = this.rotateWeekDayNames(datetime.Info.weekdays('long', {
            locale: this.locale,
        }), this.weekStartIndex);
        this.monthNames = datetime.Info.months('long', {
            locale: this.locale,
        });
    }
    /**
     * Rotate the WeekdayNames array.
     * Based on the position that should be the new 0-index.
     */
    rotateWeekDayNames(weekdays, index) {
        const clone = [...weekdays];
        if (index === 0) {
            return clone;
        }
        index = -index;
        const len = weekdays.length;
        clone.push(...clone.splice(0, ((-index % len) + len) % len));
        return clone;
    }
    async onDone() {
        const date = await this.getCurrentDate();
        this.dateSelect.emit(date);
    }
    calculateCalendar() {
        const calendar = [];
        const month = datetime.DateTime.utc(this.selectedYear, this.selectedMonth + 1);
        const monthStart = month.startOf('month');
        const monthEnd = month.endOf('month');
        let startWeek = monthStart.weekNumber;
        let endWeek = monthEnd.weekNumber;
        let monthStartWeekDayIndex = monthStart.weekday - 1;
        let monthEndWeekDayIndex = monthEnd.weekday - 1;
        if (this.weekStartIndex !== 0) {
            // Find the positions where to start/stop counting the day-numbers based on which day the week starts
            const weekdays = datetime.Info.weekdays();
            const monthStartWeekDayName = weekdays[monthStart.weekday];
            monthStartWeekDayIndex = this.dayNames.findIndex((d) => d === monthStartWeekDayName);
            const monthEndWeekDayName = weekdays[monthEnd.weekday];
            monthEndWeekDayIndex = this.dayNames.findIndex((d) => d === monthEndWeekDayName);
        }
        let correctLastWeek = false;
        if (endWeek === 1) {
            endWeek = monthEnd.weeksInWeekYear + 1;
            correctLastWeek = true;
        }
        let correctFirstWeek = false;
        if (startWeek === monthStart.weeksInWeekYear) {
            startWeek = 1;
            endWeek++;
            correctFirstWeek = true;
        }
        let currDayNumber = 1;
        for (let weekIndex = startWeek; weekIndex <= endWeek && currDayNumber <= 31; weekIndex++) {
            const daysArr = [];
            for (let j = 0; j < this.DAYS_IN_WEEK && currDayNumber <= 31; j++) {
                // Display empty cells until the calender starts/has ended
                if ((weekIndex === startWeek && j < monthStartWeekDayIndex) ||
                    (weekIndex === endWeek && j > monthEndWeekDayIndex)) {
                    daysArr.push(undefined);
                }
                else {
                    daysArr.push(currDayNumber++);
                }
            }
            if (correctFirstWeek || correctLastWeek) {
                if (weekIndex === 1) {
                    calendar.push({
                        weekNumber: monthStart.weeksInWeekYear,
                        dayNumbers: daysArr,
                    });
                }
                else if (weekIndex === monthEnd.weekNumber) {
                    calendar.push({
                        weekNumber: 1,
                        dayNumbers: daysArr,
                    });
                }
                else {
                    calendar.push({
                        weekNumber: weekIndex - 1,
                        dayNumbers: daysArr,
                    });
                }
                continue;
            }
            calendar.push({
                weekNumber: weekIndex,
                dayNumbers: daysArr,
            });
        }
        this.calendar = calendar;
    }
    selectTempYear(event, year) {
        event === null || event === void 0 ? void 0 : event.stopPropagation();
        this.tempYear = year;
    }
    focusMonth() {
        var _a;
        (_a = this.firstMonthRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
    infiniteScrollYears() {
        const yearContainer = this.yearContainerRef.current;
        if (!yearContainer) {
            return;
        }
        const scroll = yearContainer.scrollTop;
        const maxScroll = yearContainer.scrollHeight;
        const atTop = scroll === 0;
        const atBottom = Math.round(scroll + yearContainer.offsetHeight) >= maxScroll;
        const limit = 200;
        if (this.endYear - this.startYear > limit)
            return;
        if (atTop) {
            const first = yearContainer.firstElementChild;
            this.startYear -= 5;
            yearContainer.scrollTo(0, first.offsetTop);
            return;
        }
        if (atBottom) {
            const last = yearContainer.lastElementChild;
            this.endYear += 5;
            yearContainer.scrollTo(0, last.offsetTop);
        }
    }
    selectMonth(month) {
        this.selectedMonth = month;
        this.selectedYear = this.tempYear;
        this.tempMonth = month;
        const dropdown = this.hostElement.shadowRoot.querySelector('ix-dropdown');
        if (dropdown) {
            dropdown.show = false;
        }
    }
    changeToAdjacentMonth(number) {
        if (this.selectedMonth + number < 0) {
            this.selectedYear--;
            this.selectedMonth = 11;
        }
        else if (this.selectedMonth + number > 11) {
            this.selectedYear++;
            this.selectedMonth = 0;
        }
        else {
            this.selectedMonth += number;
        }
    }
    selectDay(selectedDay, target) {
        if (target.classList.contains('disabled')) {
            return;
        }
        const date = datetime.DateTime.fromJSDate(new Date(this.selectedYear, this.selectedMonth, selectedDay));
        if (this.singleSelection || this.currFromDate === undefined) {
            this.currFromDate = date;
            this.onDateChange();
            return;
        }
        // Reset the range selection
        if (this.currToDate !== undefined) {
            this.currFromDate = date;
            this.currToDate = undefined;
            this.onDateChange();
            return;
        }
        // Swap from/to if the second date is before the current date
        if (date < this.currFromDate) {
            this.currToDate = this.currFromDate;
            this.currFromDate = date;
            this.onDateChange();
            return;
        }
        // Set the range normally
        this.currToDate = date;
        this.onDateChange();
    }
    onDateChange() {
        this.getCurrentDate().then((date) => {
            this.dateChange.emit(date);
            if (!this.singleSelection) {
                this.dateRangeChange.emit(date);
            }
        });
    }
    getDayClasses(day) {
        var _a, _b, _c;
        const todayObj = this.getDateTimeNow();
        const selectedDayObj = datetime.DateTime.fromJSDate(new Date(this.selectedYear, this.selectedMonth, day));
        return {
            'calendar-item': true,
            'empty-day': day === undefined,
            today: todayObj.hasSame(selectedDayObj, 'day'),
            selected: !!(((_a = this.currFromDate) === null || _a === void 0 ? void 0 : _a.hasSame(selectedDayObj, 'day')) ||
                ((_b = this.currToDate) === null || _b === void 0 ? void 0 : _b.hasSame(selectedDayObj, 'day'))),
            range: !!(this.currFromDate &&
                selectedDayObj.startOf('day') > this.currFromDate.startOf('day') &&
                this.currToDate !== undefined &&
                selectedDayObj.startOf('day') < ((_c = this.currToDate) === null || _c === void 0 ? void 0 : _c.startOf('day'))),
            disabled: !this.isWithinMinMaxDate(selectedDayObj),
        };
    }
    isWithinMinMaxYear(year) {
        const minDateYear = this.minDate
            ? datetime.DateTime.fromFormat(this.minDate, this.format).year
            : undefined;
        const maxDateYear = this.maxDate
            ? datetime.DateTime.fromFormat(this.maxDate, this.format).year
            : undefined;
        const isBefore = minDateYear ? year < minDateYear : false;
        const isAfter = maxDateYear ? year > maxDateYear : false;
        return !isBefore && !isAfter;
    }
    isWithinMinMaxMonth(month) {
        const minDateObj = this.minDate
            ? datetime.DateTime.fromFormat(this.minDate, this.format)
            : undefined;
        const maxDateObj = this.maxDate
            ? datetime.DateTime.fromFormat(this.maxDate, this.format)
            : undefined;
        const minDateMonth = minDateObj === null || minDateObj === void 0 ? void 0 : minDateObj.month;
        const maxDateMonth = maxDateObj === null || maxDateObj === void 0 ? void 0 : maxDateObj.month;
        const isBefore = minDateMonth
            ? this.tempYear === minDateObj.year && month < minDateMonth
            : false;
        const isAfter = maxDateMonth
            ? this.tempYear === maxDateObj.year && month > maxDateMonth
            : false;
        return !isBefore && !isAfter;
    }
    isWithinMinMaxDate(date) {
        const _minDate = this.minDate
            ? datetime.DateTime.fromFormat(this.minDate, this.format)
            : undefined;
        const _maxDate = this.maxDate
            ? datetime.DateTime.fromFormat(this.maxDate, this.format)
            : undefined;
        const isBefore = _minDate
            ? date.startOf('day') < _minDate.startOf('day')
            : false;
        const isAfter = _maxDate
            ? date.startOf('day') > _maxDate.startOf('day')
            : false;
        return !isBefore && !isAfter;
    }
    renderYears() {
        const rows = [];
        for (let year = this.startYear; year <= this.endYear; year++) {
            rows.push(index.h("div", { key: year, class: {
                    arrowYear: true,
                    'month-dropdown-item': true,
                    'disabled-item': !this.isWithinMinMaxYear(year),
                }, onClick: (event) => this.selectTempYear(event, year), onKeyUp: (event) => {
                    if (event.key === 'Enter') {
                        this.tempYear = year;
                        this.focusMonth();
                    }
                }, tabIndex: 0 }, index.h("ix-icon", { class: {
                    hidden: this.tempYear !== year,
                    arrowPosition: true,
                }, name: index$1.iconChevronRightSmall, size: "12" }), index.h("div", { style: { 'min-width': 'max-content' } }, `${year}`)));
        }
        return rows;
    }
    render() {
        return (index.h(index.Host, { key: 'ac385bc586d47db0ce5aeb9eab3e7e71e71fe7cf' }, index.h("ix-date-time-card", { key: 'e1d11ba64aa8b1374c6ded705afa779a9b3966b1', corners: this.corners, embedded: this.embedded }, index.h("div", { key: 'bc99b5e074709ee8599799814a3bc7fd5ab417a5', class: "header", slot: "header" }, index.h("ix-icon-button", { key: '6bc172523c9588a3bb1d200d5113b2533117c021', onClick: () => this.changeToAdjacentMonth(-1), icon: index$1.iconChevronLeftSmall, variant: "tertiary", class: "arrows", "aria-label": this.ariaLabelPreviousMonthButton }), index.h("div", { key: 'e3505b87752b9d763ba61286f1091e67e2ee3314', class: "selector" }, index.h("ix-button", { key: 'f6740c7a4ea82875e876896ab0d311e56edf2c6d', variant: "tertiary", ref: this.dropdownButtonRef, "data-testid": "year-month-button" }, index.h("span", { key: '0cd1e04f63512e2c8798d3524c2e8cc3e719d853', class: "capitalize" }, this.monthNames[this.selectedMonth], " ", this.selectedYear)), index.h("ix-dropdown", { key: '0021b8af9b8ba6b23e9ed49ebb4edcecc55eeb26', "data-testid": "year-month-dropdown", class: "dropdown", trigger: this.dropdownButtonRef.waitForCurrent(), ignoreRelatedSubmenu: true, placement: "bottom-start" }, index.h("div", { key: 'f00cf88696bec06c49c59962d3dcb4838be3f3f2', class: "wrapper" }, index.h("div", { key: '0d6b2ca0c9a2f23a7fd1fa24cc05454da9e16af7', "data-testid": "year-container", class: "overflow", onScroll: () => this.infiniteScrollYears(), ref: this.yearContainerRef }, this.renderYears()), index.h("div", { key: 'bff068918a1f31e25f1d22b9e2f4b36e0a2affdd', class: "overflow", "data-testid": "month-container" }, this.monthNames.map((month, index$2) => (index.h("div", { key: month, ref: (ref) => {
                if (month === this.monthNames[0]) {
                    this.firstMonthRef(ref);
                }
            }, class: {
                arrowYear: true,
                'month-dropdown-item': true,
                selected: this.tempYear === this.selectedYear &&
                    this.tempMonth === index$2,
                'disabled-item': !this.isWithinMinMaxMonth(index$2),
            }, onClick: () => this.selectMonth(index$2), onKeyUp: (event) => event.key === 'Enter' && this.selectMonth(index$2), tabIndex: 0 }, index.h("ix-icon", { class: {
                hidden: this.tempYear !== this.selectedYear ||
                    this.tempMonth !== index$2,
                checkPosition: true,
            }, name: index$1.iconSingleCheck, size: "16" }), index.h("div", null, index.h("span", { class: "capitalize monthMargin" }, `${month} ${this.tempYear}`))))))))), index.h("ix-icon-button", { key: '42af554f8f382640b60f98b68708e5cb4912bf33', onClick: () => this.changeToAdjacentMonth(1), icon: index$1.iconChevronRightSmall, variant: "tertiary", class: "arrows", "aria-label": this.ariaLabelNextMonthButton })), index.h("div", { key: '565551cf265951458d43742f5a64e1d3e8107bcc', class: {
                grid: true,
                'grid--show-week-numbers': this.showWeekNumbers,
            } }, this.showWeekNumbers && index.h("div", { key: '153664ce89e84909f75d424f3af985f3c8caa22b', class: "calendar-item week-day" }), this.dayNames.map((name) => (index.h("div", { key: name, class: "calendar-item week-day" }, index.h("div", { class: "overflow" }, name.slice(0, 3))))), this.calendar.map((week) => {
            return (index.h(index.Fragment, null, this.showWeekNumbers && (index.h("div", { class: "calendar-item week-number" }, week.weekNumber)), week.dayNumbers.map((day) => {
                return day ? (index.h("div", { key: day, id: `day-cell-${day}`, "date-calender-day": true, class: this.getDayClasses(day), onClick: (e) => {
                        const target = e.currentTarget;
                        this.selectDay(day, target);
                    }, onKeyUp: (e) => {
                        const target = e.currentTarget;
                        if (e.key === 'Enter') {
                            this.selectDay(day, target);
                        }
                    }, tabIndex: day === this.focusedDay ? 0 : -1, onFocus: () => this.onDayFocus(), onBlur: () => this.onDayBlur(), "aria-label": `${this.selectedMonth}: ${day}` }, day)) : (index.h("div", null));
            })));
        })), index.h("div", { key: 'a3eaf5affbf21d93ac0bd2938a544e372ecee2bc', class: {
                button: true,
                hidden: this.singleSelection || this.embedded,
            } }, index.h("ix-button", { key: 'bcbc94626760a7c8e755f4afb52f127d5b49dcd7', onClick: () => this.onDone() }, this.i18nDone)))));
    }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "from": ["watchFromPropHandler"],
        "to": ["watchToPropHandler"],
        "locale": ["onLocaleChange"]
    }; }
};
__decorate([
    listener.OnListener('keydown')
], DatePicker.prototype, "handleKeyUp", null);
DatePicker.style = datePickerCss;

const layoutGridCss = ":host{--ix-layout-grid-gutter:24px;display:block;flex:1 1 0%;width:100%;padding-left:calc(var(--ix-layout-grid-gutter) * 0.5);padding-right:calc(var(--ix-layout-grid-gutter) * 0.5)}:host(.no-margin){padding-left:0;padding-right:0}";

const LayoutGrid = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        /**
         * The grid will not have any horizontal padding
         */
        this.noMargin = false;
        /**
         * Grid gap
         */
        this.gap = '24';
        /**
         * Overwrite the default number of columns. Choose between 2 and 12 columns.
         */
        this.columns = 12;
    }
    render() {
        return (index.h(index.Host, { key: '040fa69fa09d20fdbfc6ae40f85cdf70f74b3eee', class: {
                'no-margin': this.noMargin,
            }, style: {
                '--ix-layout-grid-columns': `${this.columns}`,
                '--ix-layout-grid-gutter': `${this.gap}px`,
            } }, index.h("slot", { key: '50cae64ab0cc69aa2ffe55bfce8f069ea22b240b' })));
    }
};
LayoutGrid.style = layoutGridCss;

const rowCss = ":host{display:flex;flex-wrap:wrap}:host(:not(:first-of-type)){margin-block-start:var(--ix-layout-grid-row-margin, 0)}";

const Row = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
    }
    render() {
        return (index.h(index.Host, { key: 'ff07b78a26aaca76105d0cf296807512620aa6e6' }, index.h("slot", { key: '46cf7e7f85f4a44831b6482df9a9b667519082f0' })));
    }
};
Row.style = rowCss;

exports.ix_col = Col;
exports.ix_date_picker = DatePicker;
exports.ix_layout_grid = LayoutGrid;
exports.ix_row = Row;
//# sourceMappingURL=ix-col.ix-date-picker.ix-layout-grid.ix-row.entry.cjs.js.map

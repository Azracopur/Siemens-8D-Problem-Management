/*
 * SPDX-FileCopyrightText: 2024 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { h, Host } from "@stencil/core";
import { a11yHostAttributes } from "../utils/a11y";
import { createClassMutationObserver, isIxInputFieldComponent, } from "../utils/input";
import { makeRef } from "../utils/make-ref";
export class FormFieldLabel {
    constructor() {
        /** @internal */
        this.isInvalid = false;
        this.htmlForObserver = new MutationObserver(() => this.checkForInternalState());
        this.a11yAttributes = {};
        this.labelRef = makeRef();
    }
    connectedCallback() {
        this.registerHtmlForObserver();
        this.registerControlRefObserver();
    }
    disconnectedCallback() {
        if (this.htmlForObserver) {
            this.htmlForObserver.disconnect();
        }
        if (this.htmlForClassObserver) {
            this.htmlForClassObserver.destroy();
        }
        if (this.controlRefClassObserver) {
            this.controlRefClassObserver.destroy();
        }
    }
    componentWillRender() {
        this.checkForInternalState();
    }
    componentWillLoad() {
        this.a11yAttributes = a11yHostAttributes(this.hostElement);
    }
    registerHtmlForObserver() {
        if (typeof window === 'undefined') {
            return;
        }
        if (this.htmlForObserver) {
            this.htmlForObserver.disconnect();
        }
        if (this.htmlFor) {
            this.htmlForObserver.observe(window.document, {
                childList: true,
                subtree: true,
            });
        }
    }
    async registerControlRefObserver() {
        if (typeof window === 'undefined') {
            return;
        }
        if (this.controlRefClassObserver) {
            this.controlRefClassObserver.destroy();
        }
        if (this.controlRef) {
            const input = await this.controlRef.waitForCurrent();
            this.controlRefClassObserver = createClassMutationObserver(input, () => this.checkForInvalidState(input));
        }
    }
    registerHtmlForClassObserver(forElement) {
        if (this.htmlForClassObserver) {
            this.htmlForClassObserver.destroy();
        }
        this.htmlForClassObserver = createClassMutationObserver(forElement, () => this.checkForInvalidState(forElement));
    }
    checkForInvalidState(elementToCheck) {
        this.isInvalid =
            elementToCheck.classList.contains('is-invalid') ||
                elementToCheck.classList.contains('ix-invalid');
    }
    async checkForInternalState() {
        if (this.htmlFor) {
            const forElement = document.getElementById(this.htmlFor);
            if (forElement) {
                if (typeof forElement.required === 'boolean') {
                    this.required = forElement.required;
                }
                this.registerHtmlForClassObserver(forElement);
                this.checkForInvalidState(forElement);
            }
        }
        if (this.controlRef) {
            const input = await this.controlRef.waitForCurrent();
            this.required = input.required;
        }
    }
    async focusOnClick() {
        if (this.htmlFor) {
            const target = document.getElementById(this.htmlFor);
            if (target) {
                let input = null;
                if (isIxInputFieldComponent(target)) {
                    input = await target.getNativeInputElement();
                }
                else {
                    input = target;
                }
                if (typeof input.focus === 'function') {
                    input.focus();
                }
            }
        }
        if (this.controlRef) {
            (await this.controlRef.waitForCurrent()).focus();
        }
    }
    render() {
        return (h(Host, { key: 'ca4f1ba84a3a19a4d15aa517272c90bebf782e13', onClick: () => this.focusOnClick() }, h("label", Object.assign({ key: '44e2386d5dd7c51d3b5a9e1530e986b15ba64d23', htmlFor: this.htmlFor }, this.a11yAttributes, { ref: this.labelRef }), h("ix-typography", { key: 'ab97048f7a521ad398438795ba7a5ccba2571f4c', textColor: this.isInvalid ? 'alarm' : 'soft', format: "label" }, h("slot", { key: 'faf628440f832acb412c7f5b40dab4620da785d7' }), this.required && h("span", { key: 'd15676e3bf2d645ce2e1fc8f3bd91af23b6ec725' }, "*")))));
    }
    static get is() { return "ix-field-label"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["field-label.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["field-label.css"]
        };
    }
    static get properties() {
        return {
            "required": {
                "type": "boolean",
                "attribute": "required",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "A value is required or must be checked for the form to be submittable"
                },
                "getter": false,
                "setter": false,
                "reflect": true
            },
            "htmlFor": {
                "type": "string",
                "attribute": "html-for",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The id of the form element that the label is associated with"
                },
                "getter": false,
                "setter": false,
                "reflect": true
            },
            "controlRef": {
                "type": "unknown",
                "attribute": "control-ref",
                "mutable": false,
                "complexType": {
                    "original": "| MakeRef<HTMLElement>\n    | MakeRef<HTMLInputElement>\n    | MakeRef<HTMLTextAreaElement>",
                    "resolved": "undefined | { (ref: HTMLElement | null | undefined): void; current: HTMLElement | null; waitForCurrent(): Promise<HTMLElement>; } | { (ref: HTMLInputElement | null | undefined): void; current: HTMLInputElement | null; waitForCurrent(): Promise<HTMLInputElement>; } | { (ref: HTMLTextAreaElement | null | undefined): void; current: HTMLTextAreaElement | null; waitForCurrent(): Promise<HTMLTextAreaElement>; }",
                    "references": {
                        "MakeRef": {
                            "location": "import",
                            "path": "../utils/make-ref",
                            "id": "src/components/utils/make-ref.ts::MakeRef"
                        },
                        "HTMLElement": {
                            "location": "global",
                            "id": "global::HTMLElement"
                        },
                        "HTMLInputElement": {
                            "location": "global",
                            "id": "global::HTMLInputElement"
                        },
                        "HTMLTextAreaElement": {
                            "location": "global",
                            "id": "global::HTMLTextAreaElement"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false
            },
            "isInvalid": {
                "type": "boolean",
                "attribute": "is-invalid",
                "mutable": true,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            }
        };
    }
    static get elementRef() { return "hostElement"; }
    static get watchers() {
        return [{
                "propName": "htmlFor",
                "methodName": "registerHtmlForObserver"
            }, {
                "propName": "controlRef",
                "methodName": "registerControlRefObserver"
            }];
    }
}
//# sourceMappingURL=field-label.js.map

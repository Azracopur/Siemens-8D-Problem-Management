/*
 * SPDX-FileCopyrightText: 2023 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { h, Host, } from "@stencil/core";
import { DateTime } from "luxon";
import { OnListener } from "../utils/listener";
const LUXON_FORMAT_PATTERNS = {
    // h, hh, H, HH and various time formats that include hours
    hours: /\b[Hh]\b|HH|hh|H{3,4}|h{3,4}|t|tt|ttt|tttt|T|TT|TTT|TTTT/,
    // m, mm and time formats that include minutes
    minutes: /\bm\b|mm|t|tt|ttt|tttt|T|TT|TTT|TTTT/,
    // s, ss and time formats that include seconds
    seconds: /\bs\b|ss|tt|ttt|tttt|TT|TTT|TTTT/,
    // S, SSS (milliseconds), u/uu/uuu (fractional seconds), x/X (timestamps)
    milliseconds: /\bS\b|SSS|u|uu|uuu/,
};
const HOUR_INTERVAL_DEFAULT = 1;
const MINUTE_INTERVAL_DEFAULT = 1;
const SECOND_INTERVAL_DEFAULT = 1;
const MILLISECOND_INTERVAL_DEFAULT = 100;
const CONFIRM_BUTTON_DEFAULT = 'Confirm';
const HEADER_DEFAULT = 'Time';
const FORMATTED_TIME_EMPTY = {
    hour: '',
    minute: '',
    second: '',
    millisecond: '',
};
export class TimePicker {
    constructor() {
        /**
         * Format of time string
         * See {@link https://moment.github.io/luxon/#/formatting?id=table-of-tokens} for all available tokens.
         * Note: Formats that combine date and time (like f or F) are not supported. Timestamp tokens x and X are not supported either.
         */
        this.format = 'TT';
        /**
         * Corner style
         */
        this.corners = 'rounded';
        /**
         * Embedded style (for use in other components)
         */
        this.embedded = false;
        /**
         * @internal Temporary prop needed until datetime-picker is reworked for new design
         */
        this.dateTimePickerAppearance = false;
        /**
         * Hides the header of the picker.
         *
         * @since 3.2.0
         */
        this.hideHeader = false;
        /**
         * Interval for hour selection
         *
         * @since 3.2.0
         */
        this.hourInterval = HOUR_INTERVAL_DEFAULT;
        /**
         * Interval for minute selection
         *
         * @since 3.2.0
         */
        this.minuteInterval = MINUTE_INTERVAL_DEFAULT;
        /**
         * Interval for second selection
         *
         * @since 3.2.0
         */
        this.secondInterval = SECOND_INTERVAL_DEFAULT;
        /**
         * Interval for millisecond selection
         *
         * @since 3.2.0
         */
        this.millisecondInterval = MILLISECOND_INTERVAL_DEFAULT;
        /**
         * Text of the time confirm button
         */
        this.i18nConfirmTime = CONFIRM_BUTTON_DEFAULT;
        /**
         * Text for top header
         */
        this.i18nHeader = HEADER_DEFAULT;
        /**
         * Text for hour column header
         */
        this.i18nHourColumnHeader = 'hr';
        /**
         * Text for minute column header
         */
        // eslint-disable-next-line @stencil-community/decorators-style
        this.i18nMinuteColumnHeader = 'min';
        /**
         * Text for second column header
         */
        // eslint-disable-next-line @stencil-community/decorators-style
        this.i18nSecondColumnHeader = 'sec';
        /**
         * Text for millisecond column header
         */
        // eslint-disable-next-line @stencil-community/decorators-style
        this.i18nMillisecondColumnHeader = 'ms';
        this.formattedTime = FORMATTED_TIME_EMPTY;
        this.timePickerDescriptors = [];
        this.isUnitFocused = false;
        this.focusedUnit = 'hour';
        this.focusedValue = 0;
        this.focusScrollAlignment = 'start';
    }
    watchFormatIntervalPropHandler(newValue) {
        if (!newValue) {
            return;
        }
        this.initPicker();
        this.updateScrollPositions();
    }
    watchHourIntervalPropHandler(newValue) {
        if (Number.isInteger(newValue) &&
            newValue >= 0 &&
            newValue <= (this.timeRef ? 12 : 23)) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('hour', newValue);
        this.hourInterval = HOUR_INTERVAL_DEFAULT;
    }
    watchMinuteIntervalPropHandler(newValue) {
        if (newValue >= 0 && newValue <= 59) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('minute', newValue);
        this.minuteInterval = MINUTE_INTERVAL_DEFAULT;
    }
    watchSecondIntervalPropHandler(newValue) {
        if (newValue >= 0 && newValue <= 59) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('second', newValue);
        this.secondInterval = SECOND_INTERVAL_DEFAULT;
    }
    watchMillisecondIntervalPropHandler(newValue) {
        if (newValue >= 0 && newValue <= 999) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('millisecond', newValue);
        this.millisecondInterval = MILLISECOND_INTERVAL_DEFAULT;
    }
    printIntervalError(intervalName, value) {
        console.error(`Value ${value} is not valid for ${intervalName}-interval. Falling back to default.`);
    }
    watchTimePropHandler(newValue) {
        const timeFormat = DateTime.fromFormat(newValue, this.format);
        if (!timeFormat.isValid) {
            throw new Error('Format is not supported or not correct');
        }
        this._time = timeFormat;
    }
    /**
     * Get default time value
     * @returns DateTime.now() for empty state (no selection)
     */
    getDefaultTime() {
        return DateTime.now();
    }
    /**
     * Get the current time based on the wanted format
     */
    async getCurrentTime() {
        var _a;
        return (_a = this._time) === null || _a === void 0 ? void 0 : _a.toFormat(this.format);
    }
    onTimeChange() {
        const formattedTimeOld = this.formattedTime;
        this.setTimeRef();
        this.formattedTime = this.getFormattedTime();
        this.updateScrollPositions(formattedTimeOld);
    }
    componentWillLoad() {
        this.initPicker();
    }
    initPicker() {
        let parsedTime;
        if (this.time) {
            parsedTime = DateTime.fromFormat(this.time, this.format);
            if (!parsedTime.isValid) {
                console.error(`Invalid time format. The configured format does not match the format of the passed time. ${parsedTime.invalidReason}: ${parsedTime.invalidExplanation}`);
                parsedTime = this.getDefaultTime();
            }
        }
        else {
            parsedTime = this.getDefaultTime();
        }
        this._time = parsedTime;
        this.setTimeRef();
        this.setTimePickerDescriptors();
        this.setInitialFocusedValueAndUnit();
        this.watchHourIntervalPropHandler(this.hourInterval);
        this.watchMinuteIntervalPropHandler(this.minuteInterval);
        this.watchSecondIntervalPropHandler(this.secondInterval);
        this.watchMillisecondIntervalPropHandler(this.millisecondInterval);
    }
    componentDidLoad() {
        this.updateScrollPositions();
        this.setupVisibilityObserver();
    }
    componentDidRender() {
        if (this.isUnitFocused) {
            const elementContainer = this.getElementContainer(this.focusedUnit, this.focusedValue);
            const elementList = this.getElementList(this.focusedUnit);
            if (elementContainer) {
                elementContainer.focus({ preventScroll: true });
                if (!this.isElementVisible(elementContainer, elementList)) {
                    this.scrollElementIntoView(elementContainer, elementList, this.focusScrollAlignment);
                }
            }
        }
    }
    disconnectedCallback() {
        if (this.visibilityObserver) {
            this.visibilityObserver.disconnect();
        }
    }
    handleKeyDown(event) {
        if (!this.isUnitFocused) {
            return;
        }
        let newValue = this.focusedValue;
        let shouldPreventDefault = true;
        let newValueInterval;
        switch (this.focusedUnit) {
            case 'hour':
                newValueInterval = this.hourInterval;
                break;
            case 'minute':
                newValueInterval = this.minuteInterval;
                break;
            case 'second':
                newValueInterval = this.secondInterval;
                break;
            case 'millisecond':
                newValueInterval = this.millisecondInterval;
                break;
        }
        switch (event.key) {
            case 'Tab':
                shouldPreventDefault = false;
                this.isUnitFocused = false;
                break;
            case 'ArrowUp':
                newValue -= newValueInterval;
                this.focusScrollAlignment = 'start';
                this.updateFocusedValue(newValue);
                this.updateDescriptorFocusedValue(this.focusedUnit, this.focusedValue);
                break;
            case 'ArrowDown':
                newValue += newValueInterval;
                this.focusScrollAlignment = 'end';
                this.updateFocusedValue(newValue);
                this.updateDescriptorFocusedValue(this.focusedUnit, this.focusedValue);
                break;
            case 'Enter':
            case ' ':
                this.select(this.focusedUnit, this.focusedValue);
                break;
            default:
                return;
        }
        if (shouldPreventDefault) {
            event.preventDefault();
        }
    }
    onUnitCellBlur(unit, event) {
        var _a;
        const relatedTarget = event.relatedTarget;
        // Check if column lost focus to scroll back to selected value
        if (relatedTarget) {
            const relatedUnit = (_a = relatedTarget.dataset.elementContainerId) === null || _a === void 0 ? void 0 : _a.split('-')[0];
            if (relatedUnit !== unit) {
                this.elementListScrollToTop(unit, Number(this.formattedTime[unit]), 'smooth');
            }
        }
        this.isUnitFocused = false;
        const focusedValue = Number(this.formattedTime[unit]);
        this.updateDescriptorFocusedValue(unit, focusedValue);
    }
    onUnitCellFocus(unit, value) {
        this.isUnitFocused = true;
        this.focusedUnit = unit;
        this.focusedValue = value;
        this.updateDescriptorFocusedValue(unit, value);
    }
    getElementList(unit) {
        var _a;
        return (_a = this.hostElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-element-list-id="${unit}"]`);
    }
    getElementContainer(unit, number) {
        var _a;
        return (_a = this.hostElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-element-container-id="${unit}-${number}"]`);
    }
    isElementVisible(element, container) {
        const elementRect = element.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        return (elementRect.top >= containerRect.top &&
            elementRect.bottom <= containerRect.bottom);
    }
    scrollElementIntoView(element, container, alignment) {
        const SCROLL_BUFFER = 1;
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        if (alignment === 'end') {
            container.scrollTop +=
                elementRect.bottom - containerRect.bottom + SCROLL_BUFFER;
        }
        else {
            container.scrollTop +=
                elementRect.top - containerRect.top - SCROLL_BUFFER;
        }
    }
    updateFocusedValue(value) {
        const numberArray = this.getNumberArrayForUnit(this.focusedUnit);
        const maxValue = numberArray[numberArray.length - 1];
        const minValue = numberArray[0];
        if (value > maxValue) {
            value = minValue;
            this.focusScrollAlignment = 'start';
        }
        else if (value < minValue) {
            value = maxValue;
            this.focusScrollAlignment = 'end';
        }
        this.focusedValue = value;
    }
    setInitialFocusedValueAndUnit() {
        const firstVisibleDescriptor = this.timePickerDescriptors.find((descriptor) => !descriptor.hidden);
        if (!firstVisibleDescriptor) {
            return;
        }
        const selectedValue = Number(this.formattedTime[firstVisibleDescriptor.unit]);
        const isValidSelection = firstVisibleDescriptor.numberArray.includes(selectedValue);
        this.focusedValue = isValidSelection
            ? selectedValue
            : firstVisibleDescriptor.numberArray[0];
        this.focusedUnit = firstVisibleDescriptor.unit;
    }
    setupVisibilityObserver() {
        let dropdownElement = this.hostElement;
        while (dropdownElement && dropdownElement.tagName !== 'IX-DROPDOWN') {
            dropdownElement = dropdownElement.parentElement;
        }
        if (!dropdownElement) {
            return;
        }
        this.visibilityObserver = new MutationObserver((mutations) => this.mutationObserverCallback(mutations));
        this.visibilityObserver.observe(dropdownElement, {
            attributes: true,
            attributeFilter: ['class', 'style'],
        });
    }
    mutationObserverCallback(mutations) {
        for (const mutation of mutations) {
            if (mutation.type !== 'attributes') {
                continue;
            }
            const dropdown = mutation.target;
            if (!dropdown.classList.contains('show')) {
                // keep picker in sync with input
                if (this.time) {
                    const timeFormat = DateTime.fromFormat(this.time, this.format);
                    if (timeFormat.isValid) {
                        this._time = DateTime.fromFormat(this.time, this.format);
                        this.setInitialFocusedValueAndUnit();
                    }
                }
                continue;
            }
            const elementsReady = this.areElementsRendered();
            if (!elementsReady) {
                continue;
            }
            this.updateScrollPositions();
        }
    }
    areElementsRendered() {
        var _a;
        const elementLists = (_a = this.hostElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.element-list');
        if (!elementLists || elementLists.length === 0) {
            return false;
        }
        return Array.from(elementLists).some((list) => list.offsetHeight > 0);
    }
    getFormattedTime() {
        if (!this._time) {
            return FORMATTED_TIME_EMPTY;
        }
        return {
            hour: this.timeRef !== undefined
                ? this._time.toFormat('h')
                : this._time.toFormat('H'),
            minute: this._time.toFormat('m'),
            second: this._time.toFormat('s'),
            millisecond: this._time.toFormat('S'),
        };
    }
    timeUpdate(unit, value) {
        let maxValue = DateTime.now().endOf('day').get(unit);
        if (unit === 'hour') {
            if (this.timeRef === 'PM') {
                // 12 PM should remain 12, other PM hours add 12
                value = value === 12 ? 12 : value + 12;
            }
            else if (this.timeRef === 'AM') {
                // 12 AM should be 0, other AM hours remain as is
                value = value === 12 ? 0 : value;
                maxValue = 12;
            }
        }
        if (value > maxValue) {
            value = maxValue;
        }
        else if (value < 0) {
            value = 0;
        }
        if (!this._time) {
            this._time = DateTime.now().startOf('day');
        }
        this._time = this._time.set({
            [unit]: value,
        });
        return value;
    }
    changeTimeReference(newTimeRef) {
        if (this.timeRef === newTimeRef) {
            return;
        }
        if (!this._time) {
            this._time = DateTime.now().startOf('day');
        }
        this.timeRef = newTimeRef;
        const currentHour = this._time.hour;
        if (newTimeRef === 'PM' && currentHour < 12) {
            this._time = this._time.plus({ hours: 12 });
        }
        else if (newTimeRef === 'AM' && currentHour >= 12) {
            this._time = this._time.minus({ hours: 12 });
        }
        this.timeChange.emit(this._time.toFormat(this.format));
    }
    isFormat12Hour(format) {
        // Remove any text that's inside quotes (literal text in Luxon format strings)
        let cleanFormat = '';
        let inQuote = false;
        for (let i = 0; i < format.length; i++) {
            const char = format[i];
            if (char === "'") {
                inQuote = !inQuote;
            }
            else if (!inQuote) {
                cleanFormat += char;
            }
        }
        // Check for specific 12-hour format tokens
        // Case-sensitive matching to distinguish between 'h' and 'H'
        return /h|a|t/.test(cleanFormat);
    }
    setTimeRef() {
        const uses12HourFormat = this.isFormat12Hour(this.format);
        if (uses12HourFormat && this._time) {
            this.timeRef = this._time.hour >= 12 ? 'PM' : 'AM';
        }
        else {
            this.timeRef = undefined;
        }
    }
    getInitialFocusedValueForUnit(unit, numberArray) {
        const selectedValue = Number(this.formattedTime[unit]);
        return numberArray.includes(selectedValue) ? selectedValue : numberArray[0];
    }
    setTimePickerDescriptors() {
        let hourNumbers = [];
        let minuteNumbers = [];
        let secondNumbers = [];
        let millisecondsNumbers = [];
        if (this.timeRef !== undefined) {
            hourNumbers = Array.from({ length: Math.ceil(12 / this.hourInterval) }, (_, i) => i * this.hourInterval + 1).filter((hour) => hour <= 12);
        }
        else {
            hourNumbers = Array.from({ length: Math.ceil(24 / this.hourInterval) }, (_, i) => i * this.hourInterval);
        }
        minuteNumbers = Array.from({ length: Math.ceil(60 / this.minuteInterval) }, (_, i) => i * this.minuteInterval);
        secondNumbers = Array.from({ length: Math.ceil(60 / this.secondInterval) }, (_, i) => i * this.secondInterval);
        millisecondsNumbers = Array.from({ length: Math.ceil(1000 / this.millisecondInterval) }, (_, i) => i * this.millisecondInterval);
        this.timePickerDescriptors = [
            {
                unit: 'hour',
                header: this.i18nHourColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.hours.test(this.format),
                numberArray: hourNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('hour', hourNumbers),
            },
            {
                unit: 'minute',
                header: this.i18nMinuteColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.minutes.test(this.format),
                numberArray: minuteNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('minute', minuteNumbers),
            },
            {
                unit: 'second',
                header: this.i18nSecondColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.seconds.test(this.format),
                numberArray: secondNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('second', secondNumbers),
            },
            {
                unit: 'millisecond',
                header: this.i18nMillisecondColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.milliseconds.test(this.format),
                numberArray: millisecondsNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('millisecond', millisecondsNumbers),
            },
        ];
        this.timePickerDescriptors = this.timePickerDescriptors.filter((item) => !item.hidden);
    }
    getNumberArrayForUnit(unit) {
        const descriptor = this.timePickerDescriptors.find((descriptor) => descriptor.unit === unit);
        return descriptor ? descriptor.numberArray : [];
    }
    isSelected(unit, number) {
        return this.formattedTime[unit] === String(number);
    }
    select(unit, number) {
        if (this.isSelected(unit, number)) {
            return;
        }
        this.formattedTime = Object.assign(Object.assign({}, this.formattedTime), { [unit]: String(number) });
        this.timeUpdate(unit, number);
        this.elementListScrollToTop(unit, number, 'smooth');
        this.timeChange.emit(this._time.toFormat(this.format));
    }
    updateDescriptorFocusedValue(unit, value) {
        const descriptorIndex = this.timePickerDescriptors.findIndex((d) => d.unit === unit);
        if (descriptorIndex !== -1) {
            this.timePickerDescriptors = [
                ...this.timePickerDescriptors.slice(0, descriptorIndex),
                Object.assign(Object.assign({}, this.timePickerDescriptors[descriptorIndex]), { focusedValue: value }),
                ...this.timePickerDescriptors.slice(descriptorIndex + 1),
            ];
        }
    }
    elementListScrollToTop(unit, number, scrollBehaviour) {
        const elementList = this.getElementList(unit);
        const elementContainer = this.getElementContainer(unit, number);
        if (elementList && elementContainer) {
            const elementListHeight = elementList.clientHeight;
            const elementContainerHeight = elementContainer.clientHeight;
            // Offset which is used to adjust the scroll position to account for margins, elements being hidden, etc.
            let scrollPositionOffset = 11;
            if (this.hideHeader) {
                // 56 + 1 --> height of the header container and separator
                scrollPositionOffset -= 57;
            }
            const scrollPosition = elementContainer.offsetTop -
                elementListHeight / 2 +
                elementContainerHeight -
                scrollPositionOffset;
            elementList.scrollTo({
                top: scrollPosition,
                behavior: scrollBehaviour,
            });
        }
    }
    /**
     * Updates all scroll positions of the time picker elements
     * Updates only the elements that have changed if `formattedTimeOld` is provided
     */
    updateScrollPositions(formattedTimeOld = undefined) {
        for (const key in this.formattedTime) {
            const unitKey = key;
            if (!formattedTimeOld ||
                this.formattedTime[unitKey] !== formattedTimeOld[unitKey]) {
                this.elementListScrollToTop(unitKey, Number(this.formattedTime[unitKey]), 'instant');
            }
        }
    }
    formatUnitValue(unit, value) {
        if (unit === 'millisecond') {
            return value.toString().padStart(3, '0');
        }
        return value < 10 ? `0${value}` : value.toString();
    }
    getColumnSeparator(currentIndex) {
        if (currentIndex + 1 < this.timePickerDescriptors.length) {
            const nextUnit = this.timePickerDescriptors[currentIndex + 1].unit;
            return nextUnit === 'millisecond' ? '.' : ':';
        }
        return ':';
    }
    getElementContainerTabIndex(number, descriptorUnit) {
        const descriptor = this.timePickerDescriptors.find((d) => d.unit === descriptorUnit);
        if (number === (descriptor === null || descriptor === void 0 ? void 0 : descriptor.focusedValue)) {
            return '0';
        }
        return '-1';
    }
    render() {
        return (h(Host, { key: 'da95d86956db27851713b28d3727ee9d8e33f785' }, h("ix-date-time-card", { key: '5a8a88d641f859eaa2c1e1e2f7b699abd56f7f74', embedded: this.embedded, timePickerAppearance: true, corners: this.corners, hasFooter: !this.dateTimePickerAppearance, hideHeader: this.hideHeader }, h("div", { key: '85639253213bee998504da73ea4de0421cf146c3', class: "header", slot: "header" }, h("ix-typography", { key: '0a21cf47dd51eaf17c44271dbe4d63d909523055', format: "body" }, this.i18nHeader)), h("div", { key: '9d716194b4a37662e298e8d59c54142e78b9a6a0', class: "clock" }, this.timePickerDescriptors.map((descriptor, index) => (h("div", { class: "flex" }, h("div", { class: { columns: true, hidden: descriptor.hidden } }, h("div", { class: "column-header", title: descriptor.header }, descriptor.header), h("div", { "data-element-list-id": descriptor.unit, class: "element-list", tabIndex: -1 }, descriptor.numberArray.map((number) => {
            return (h("button", { "data-element-container-id": `${descriptor.unit}-${number}`, class: {
                    selected: this.isSelected(descriptor.unit, number),
                    'element-container': true,
                }, onClick: () => {
                    this.select(descriptor.unit, number);
                }, onFocus: () => this.onUnitCellFocus(descriptor.unit, number), onBlur: (e) => this.onUnitCellBlur(descriptor.unit, e), tabindex: this.getElementContainerTabIndex(number, descriptor.unit), "aria-label": `${descriptor.header}: ${number}` }, this.formatUnitValue(descriptor.unit, number)));
        }), h("div", { class: "element-list-padding" }))), index !== this.timePickerDescriptors.length - 1 && (h("div", { class: {
                'column-separator': true,
                hidden: descriptor.hidden,
            } }, this.getColumnSeparator(index)))))), this.timeRef && (h("div", { key: 'b177d5ea743648618ab6b877f60a37b46d8a5fa5', class: "flex" }, h("div", { key: 'a714f52d250386088368bdfe5c28ad45a1fe2dd0', class: "column-separator" }), h("div", { key: 'c7730b336e486ec34fd23e293b8e70e309d153fe', class: "columns" }, h("div", { key: '56677d7c350e235777e5d06afd61b925934923d6', class: "column-header", title: "AM/PM" }), h("div", { key: '764fd7297bdafaa69d24c9a2655c9d4fa7a73966', class: "element-list", tabIndex: -1 }, h("button", { key: '6b7ddefac72c7d4a778e8de6c42fd593003f5e5f', "data-am-pm-id": "AM", class: {
                selected: this.timeRef === 'AM',
                'element-container': true,
            }, onClick: () => this.changeTimeReference('AM'), tabindex: "0", "aria-label": "AM" }, "AM"), h("button", { key: '75cccf55946da3b04faac2da0bd3c989b8f633a3', "data-am-pm-id": "PM", class: {
                selected: this.timeRef === 'PM',
                'element-container': true,
            }, onClick: () => this.changeTimeReference('PM'), tabindex: "0", "aria-label": "PM" }, "PM")))))), h("div", { key: 'e033175f6d142fd73661703c89c975874bc9d6be', class: {
                footer: true,
                'footer--compact': this.timePickerDescriptors.length <= 2,
            }, slot: "footer" }, h("ix-button", { key: '795d890b983737fd09cc7471c428266945062262', class: "confirm-button", onClick: () => {
                var _a;
                this.timeSelect.emit((_a = this._time) === null || _a === void 0 ? void 0 : _a.toFormat(this.format));
            } }, this.i18nConfirmTime)))));
    }
    static get is() { return "ix-time-picker"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["time-picker.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["time-picker.css"]
        };
    }
    static get properties() {
        return {
            "format": {
                "type": "string",
                "attribute": "format",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Format of time string\nSee {@link https://moment.github.io/luxon/#/formatting?id=table-of-tokens} for all available tokens.\nNote: Formats that combine date and time (like f or F) are not supported. Timestamp tokens x and X are not supported either."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'TT'"
            },
            "corners": {
                "type": "string",
                "attribute": "corners",
                "mutable": false,
                "complexType": {
                    "original": "TimePickerCorners",
                    "resolved": "\"left\" | \"right\" | \"rounded\" | \"straight\"",
                    "references": {
                        "TimePickerCorners": {
                            "location": "import",
                            "path": "./time-picker.types",
                            "id": "src/components/time-picker/time-picker.types.ts::TimePickerCorners"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Corner style"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'rounded'"
            },
            "embedded": {
                "type": "boolean",
                "attribute": "embedded",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Embedded style (for use in other components)"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "dateTimePickerAppearance": {
                "type": "boolean",
                "attribute": "date-time-picker-appearance",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": "Temporary prop needed until datetime-picker is reworked for new design"
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "hideHeader": {
                "type": "boolean",
                "attribute": "hide-header",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.2.0"
                        }],
                    "text": "Hides the header of the picker."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "hourInterval": {
                "type": "number",
                "attribute": "hour-interval",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.2.0"
                        }],
                    "text": "Interval for hour selection"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "HOUR_INTERVAL_DEFAULT"
            },
            "minuteInterval": {
                "type": "number",
                "attribute": "minute-interval",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.2.0"
                        }],
                    "text": "Interval for minute selection"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "MINUTE_INTERVAL_DEFAULT"
            },
            "secondInterval": {
                "type": "number",
                "attribute": "second-interval",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.2.0"
                        }],
                    "text": "Interval for second selection"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "SECOND_INTERVAL_DEFAULT"
            },
            "millisecondInterval": {
                "type": "number",
                "attribute": "millisecond-interval",
                "mutable": true,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.2.0"
                        }],
                    "text": "Interval for millisecond selection"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "MILLISECOND_INTERVAL_DEFAULT"
            },
            "time": {
                "type": "string",
                "attribute": "time",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Select time with format string\nFormat has to match the `format` property."
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "i18nConfirmTime": {
                "type": "string",
                "attribute": "i18n-confirm-time",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text of the time confirm button"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "CONFIRM_BUTTON_DEFAULT"
            },
            "i18nHeader": {
                "type": "string",
                "attribute": "i18n-header",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text for top header"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "HEADER_DEFAULT"
            },
            "i18nHourColumnHeader": {
                "type": "string",
                "attribute": "i18n-column-header",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text for hour column header"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'hr'"
            },
            "i18nMinuteColumnHeader": {
                "type": "string",
                "attribute": "i18n-minute-column-header",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text for minute column header"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'min'"
            },
            "i18nSecondColumnHeader": {
                "type": "string",
                "attribute": "i18n-second-column-header",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text for second column header"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'sec'"
            },
            "i18nMillisecondColumnHeader": {
                "type": "string",
                "attribute": "i18n-millisecond-column-header",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text for millisecond column header"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'ms'"
            }
        };
    }
    static get states() {
        return {
            "_time": {},
            "timeRef": {},
            "formattedTime": {},
            "timePickerDescriptors": {},
            "isUnitFocused": {},
            "focusedUnit": {},
            "focusedValue": {}
        };
    }
    static get events() {
        return [{
                "method": "timeSelect",
                "name": "timeSelect",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Time event"
                },
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                }
            }, {
                "method": "timeChange",
                "name": "timeChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Time change event"
                },
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                }
            }];
    }
    static get methods() {
        return {
            "getCurrentTime": {
                "complexType": {
                    "signature": "() => Promise<string | undefined>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<string | undefined>"
                },
                "docs": {
                    "text": "Get the current time based on the wanted format",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "hostElement"; }
    static get watchers() {
        return [{
                "propName": "format",
                "methodName": "watchFormatIntervalPropHandler"
            }, {
                "propName": "hourInterval",
                "methodName": "watchHourIntervalPropHandler"
            }, {
                "propName": "minuteInterval",
                "methodName": "watchMinuteIntervalPropHandler"
            }, {
                "propName": "secondInterval",
                "methodName": "watchSecondIntervalPropHandler"
            }, {
                "propName": "millisecondInterval",
                "methodName": "watchMillisecondIntervalPropHandler"
            }, {
                "propName": "time",
                "methodName": "watchTimePropHandler"
            }, {
                "propName": "_time",
                "methodName": "onTimeChange"
            }];
    }
}
__decorate([
    OnListener('keydown')
], TimePicker.prototype, "handleKeyDown", null);
//# sourceMappingURL=time-picker.js.map

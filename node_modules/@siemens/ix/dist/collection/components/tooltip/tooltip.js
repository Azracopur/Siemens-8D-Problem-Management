/*
 * SPDX-FileCopyrightText: 2025 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
import { arrow, autoUpdate, computePosition, flip, hide, offset, shift, } from "@floating-ui/dom";
import { h, Host, } from "@stencil/core";
import { resolveSelector } from "../utils/find-element";
import { makeRef } from "../utils/make-ref";
import { getSlottedElements } from "../utils/shadow-dom";
import { addDisposableEventListenerAsArray } from "../utils/disposable-event-listener";
const ARROW_OFFSET = -6;
const numberToPixel = (value) => value !== null ? `${value}px` : '';
let tooltipInstance = 0;
/**
 * @slot title-icon - Icon displayed next to the tooltip title. The icon will be displayed as 16x16px.
 * @slot title-content - Content of tooltip title
 */
export class Tooltip {
    constructor() {
        /**
         * Define if the user can access the tooltip via mouse.
         */
        this.interactive = false;
        /**
         * Initial placement of the tooltip.
         * If the selected placement doesn't have enough space, the tooltip will be repositioned to another location.
         */
        this.placement = 'top';
        /** @internal */
        this.showDelay = 0;
        /** @internal */
        this.hideDelay = 50;
        /** @internal */
        this.animationFrame = false;
        this.visible = false;
        this.instance = tooltipInstance++;
        this.dialogRef = makeRef();
    }
    get arrowElement() {
        return this.hostElement.shadowRoot.querySelector('.arrow');
    }
    /** @internal */
    async showTooltip(anchorElement) {
        this.clearTimeouts();
        if (this.showTooltipTimeout || this.visibleFor === anchorElement) {
            return;
        }
        const dialog = await this.dialogRef.waitForCurrent();
        this.showTooltipTimeout = setTimeout(() => {
            this.setAnchorElement(anchorElement);
            dialog.showPopover();
            this.applyTooltipPosition(anchorElement, dialog);
            this.registerTooltipListener(dialog);
        }, this.showDelay);
    }
    /** @internal */
    async hideTooltip(hideDelay = this.hideDelay) {
        this.clearTimeouts();
        if (this.hideTooltipTimeout || !this.visible) {
            return;
        }
        if (this.interactive && hideDelay === 50) {
            hideDelay = 150;
        }
        const dialog = await this.dialogRef.waitForCurrent();
        this.hideTooltipTimeout = setTimeout(() => {
            var _a, _b;
            this.setAnchorElement();
            dialog.hidePopover();
            (_a = this.disposeAutoUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
            (_b = this.disposeTooltipListener) === null || _b === void 0 ? void 0 : _b.call(this);
        }, hideDelay);
    }
    setAnchorElement(anchorElement) {
        if (!anchorElement) {
            this.visibleFor = undefined;
            this.visible = false;
        }
        else {
            this.visibleFor = anchorElement;
            this.visible = true;
        }
    }
    computeArrowPosition({ placement, middlewareData, }) {
        let { x, y } = middlewareData.arrow;
        const resetPosition = {
            top: 'unset',
            right: 'unset',
            bottom: 'unset',
            left: 'unset',
        };
        if (placement.startsWith('top')) {
            return Object.assign(Object.assign({}, resetPosition), { left: numberToPixel(x), bottom: numberToPixel(ARROW_OFFSET) });
        }
        if (placement.startsWith('right')) {
            return Object.assign(Object.assign({}, resetPosition), { left: numberToPixel(ARROW_OFFSET), top: numberToPixel(y) });
        }
        if (placement.startsWith('bottom')) {
            return Object.assign(Object.assign({}, resetPosition), { left: numberToPixel(x), top: numberToPixel(ARROW_OFFSET) });
        }
        if (placement.startsWith('left')) {
            return Object.assign(Object.assign({}, resetPosition), { right: numberToPixel(ARROW_OFFSET), top: numberToPixel(y) });
        }
    }
    async computeTooltipPosition(target, dialog) {
        return computePosition(target, dialog, {
            strategy: 'fixed',
            placement: this.placement,
            middleware: [
                shift(),
                offset(12),
                arrow({
                    element: this.arrowElement,
                }),
                flip({
                    fallbackStrategy: 'initialPlacement',
                    fallbackAxisSideDirection: 'end',
                    padding: 10,
                }),
                hide(),
            ],
        });
    }
    applyTooltipArrowPosition(computeResponse) {
        const arrowPosition = this.computeArrowPosition(computeResponse);
        Object.assign(this.arrowElement.style, arrowPosition);
    }
    async applyTooltipPosition(target, dialog) {
        if (!target) {
            return;
        }
        return new Promise((resolve) => {
            var _a;
            (_a = this.disposeAutoUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposeAutoUpdate = autoUpdate(target, dialog, async () => {
                var _a;
                const computeResponse = await this.computeTooltipPosition(target, dialog);
                const isHidden = (_a = computeResponse.middlewareData.hide) === null || _a === void 0 ? void 0 : _a.referenceHidden;
                if (isHidden) {
                    this.hideTooltip(0);
                    resolve(computeResponse);
                }
                if (computeResponse.middlewareData.arrow) {
                    this.applyTooltipArrowPosition(computeResponse);
                }
                const { x, y } = computeResponse;
                Object.assign(dialog.style, {
                    left: numberToPixel(x),
                    top: numberToPixel(y),
                });
                resolve(computeResponse);
            }, {
                ancestorResize: true,
                ancestorScroll: true,
                elementResize: true,
                animationFrame: this.animationFrame,
            });
        });
    }
    async queryAnchorElements() {
        if (this.for) {
            if (Array.isArray(this.for)) {
                return this.resolveElements(this.for);
            }
            else {
                return this.resolveElements([this.for]);
            }
        }
    }
    async resolveElements(references) {
        const elements = [];
        await Promise.all(references.map(async (reference) => {
            if (typeof reference === 'string') {
                const resolvedElements = await resolveSelector(reference, this.hostElement);
                if (resolvedElements) {
                    elements.push(...resolvedElements);
                }
            }
            else if (reference instanceof HTMLElement) {
                elements.push(reference);
            }
            else if (reference instanceof Promise) {
                elements.push(await reference);
            }
        }));
        return elements;
    }
    async registerTriggerListener() {
        var _a;
        (_a = this.disposeTriggerListener) === null || _a === void 0 ? void 0 : _a.call(this);
        const triggerElementList = await this.queryAnchorElements();
        if (!triggerElementList) {
            return;
        }
        const listeners = [];
        triggerElementList.forEach((element) => {
            listeners.push(...[
                {
                    element: element,
                    eventType: 'mouseenter',
                    callback: () => {
                        this.showTooltip(element);
                    },
                },
                {
                    element: element,
                    eventType: 'mouseleave',
                    callback: () => {
                        this.hideTooltip();
                    },
                },
                {
                    element: element,
                    eventType: 'focus',
                    callback: () => {
                        this.showTooltip(element);
                    },
                },
                {
                    element: element,
                    eventType: 'focusout',
                    callback: () => {
                        this.hideTooltip();
                    },
                },
            ]);
        });
        this.disposeTriggerListener = addDisposableEventListenerAsArray(listeners);
    }
    registerTooltipListener(dialog) {
        var _a;
        (_a = this.disposeTooltipListener) === null || _a === void 0 ? void 0 : _a.call(this);
        this.disposeTooltipListener = addDisposableEventListenerAsArray([
            {
                element: dialog,
                eventType: 'mouseenter',
                callback: () => {
                    if (this.interactive) {
                        this.clearHideTimeout();
                    }
                },
            },
            {
                element: dialog,
                eventType: 'focus',
                callback: () => {
                    if (this.interactive) {
                        this.clearHideTimeout();
                    }
                },
            },
            {
                element: dialog,
                eventType: 'mouseleave',
                callback: () => {
                    this.hideTooltip();
                },
            },
            {
                element: dialog,
                eventType: 'focusout',
                callback: () => {
                    this.hideTooltip();
                },
            },
            {
                element: dialog,
                eventType: 'click',
                callback: (event) => {
                    event.stopPropagation();
                },
            },
            {
                element: document,
                eventType: 'keydown',
                callback: (event) => {
                    if (event.key === 'Escape') {
                        this.hideTooltip();
                    }
                },
            },
        ]);
    }
    registerDomChangeListener() {
        const observer = new MutationObserver(() => {
            this.registerTriggerListener();
        });
        observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['data-ix-tooltip'],
            childList: true,
            subtree: true,
        });
        this.disposeDomChangeListener = () => {
            observer.disconnect();
        };
    }
    clearHideTimeout() {
        clearTimeout(this.hideTooltipTimeout);
        this.hideTooltipTimeout = undefined;
    }
    clearShowTimeout() {
        clearTimeout(this.showTooltipTimeout);
        this.showTooltipTimeout = undefined;
    }
    clearTimeouts() {
        this.clearHideTimeout();
        this.clearShowTimeout();
    }
    componentWillLoad() {
        this.registerTriggerListener();
    }
    componentDidLoad() {
        this.registerDomChangeListener();
    }
    disconnectedCallback() {
        var _a, _b, _c, _d;
        this.clearTimeouts();
        (_a = this.disposeAutoUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this.disposeTriggerListener) === null || _b === void 0 ? void 0 : _b.call(this);
        (_c = this.disposeTooltipListener) === null || _c === void 0 ? void 0 : _c.call(this);
        (_d = this.disposeDomChangeListener) === null || _d === void 0 ? void 0 : _d.call(this);
    }
    handleTitleIconSlotChange(e) {
        const slot = e.target;
        const elements = getSlottedElements(slot);
        for (const element of elements) {
            if (element.tagName.toLowerCase() === 'ix-icon') {
                element.size = '16';
            }
        }
    }
    render() {
        return (h(Host, { key: '1176f8e37f2918a9708c8ccdbfc57f99508299f3', role: "tooltip", class: { visible: this.visible } }, h("dialog", { key: 'd4942b8d171e7e48defc505179d54ce09288c905', ref: this.dialogRef, id: 'tooltip-' + this.instance, class: "dialog", popover: "manual", inert: !this.visible }, h("div", { key: 'faef3b3e4b5a45ddb3872bd9d8ec1d6eb4a36221', class: "tooltip-container" }, h("div", { key: 'ce64bda5406c6a70ccddc41f0b4aa4010be1aca9', class: "content-wrapper" }, h("div", { key: '52a51ed895ea573d3e889e57a05f65193906492c', class: 'tooltip-title' }, h("slot", { key: 'b7965bd9963fcd789331e4c264e8d317bf7ed314', name: "title-icon", onSlotchange: (e) => this.handleTitleIconSlotChange(e) }), h("ix-typography", { key: 'b530dbbf13b752968decb45af3953f42e3a0c743', format: "h5" }, this.titleContent, h("slot", { key: 'c7152f89180904044dc26f996923cc5766ea1d0f', name: "title-content" }))), h("slot", { key: '3b00e9ed924a0c0d8527344c13a3c52a9afd0108' }), h("div", { key: '5401e6015c3a7ebf4749edc466ddca881e4f7d36', class: "arrow" }))))));
    }
    static get is() { return "ix-tooltip"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["tooltip.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["tooltip.css"]
        };
    }
    static get properties() {
        return {
            "for": {
                "type": "string",
                "attribute": "for",
                "mutable": false,
                "complexType": {
                    "original": "ElementReference | ElementReference[]",
                    "resolved": "ElementReference[] | HTMLElement | Promise<HTMLElement> | string | undefined",
                    "references": {
                        "ElementReference": {
                            "location": "import",
                            "path": "src/components",
                            "id": "src/components.d.ts::ElementReference"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "CSS selector for hover trigger element e.g. `for=\"[data-my-custom-select]\"`"
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "titleContent": {
                "type": "string",
                "attribute": "title-content",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Title of the tooltip"
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "interactive": {
                "type": "boolean",
                "attribute": "interactive",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Define if the user can access the tooltip via mouse."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "placement": {
                "type": "string",
                "attribute": "placement",
                "mutable": false,
                "complexType": {
                    "original": "'top' | 'right' | 'bottom' | 'left'",
                    "resolved": "\"bottom\" | \"left\" | \"right\" | \"top\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Initial placement of the tooltip.\nIf the selected placement doesn't have enough space, the tooltip will be repositioned to another location."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'top'"
            },
            "showDelay": {
                "type": "number",
                "attribute": "show-delay",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "0"
            },
            "hideDelay": {
                "type": "number",
                "attribute": "hide-delay",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "50"
            },
            "animationFrame": {
                "type": "boolean",
                "attribute": "animation-frame",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            }
        };
    }
    static get states() {
        return {
            "visible": {}
        };
    }
    static get methods() {
        return {
            "showTooltip": {
                "complexType": {
                    "signature": "(anchorElement: Element) => Promise<void>",
                    "parameters": [{
                            "name": "anchorElement",
                            "type": "Element",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "Element": {
                            "location": "import",
                            "path": "@stencil/core",
                            "id": "../../node_modules/.pnpm/@stencil+core@4.37.1/node_modules/@stencil/core/internal/stencil-core/index.d.ts::Element"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }]
                }
            },
            "hideTooltip": {
                "complexType": {
                    "signature": "(hideDelay?: number) => Promise<void>",
                    "parameters": [{
                            "name": "hideDelay",
                            "type": "number",
                            "docs": ""
                        }],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        }
                    },
                    "return": "Promise<void>"
                },
                "docs": {
                    "text": "",
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }]
                }
            }
        };
    }
    static get elementRef() { return "hostElement"; }
}
//# sourceMappingURL=tooltip.js.map

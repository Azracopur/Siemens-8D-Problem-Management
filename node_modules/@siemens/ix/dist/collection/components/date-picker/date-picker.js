/*
 * SPDX-FileCopyrightText: 2023 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { iconChevronLeftSmall, iconChevronRightSmall, iconSingleCheck, } from "@siemens/ix-icons/icons";
import { Fragment, h, Host, } from "@stencil/core";
import { DateTime, Info } from "luxon";
import { OnListener } from "../utils/listener";
import { makeRef } from "../utils/make-ref";
export class DatePicker {
    constructor() {
        /**
         * Date format string.
         * See {@link https://moment.github.io/luxon/#/formatting?id=table-of-tokens} for all available tokens.
         */
        this.format = 'yyyy/LL/dd';
        /**
         * If true disables date range selection (from/to).
         */
        this.singleSelection = false;
        /**
         * Corner style
         */
        this.corners = 'rounded';
        /**
         * The earliest date that can be selected by the date picker.
         * If not set there will be no restriction.
         */
        this.minDate = '';
        /**
         * The latest date that can be selected by the date picker.
         * If not set there will be no restriction.
         */
        this.maxDate = '';
        /**
         * Text of date select button
         */
        this.i18nDone = 'Done';
        /**
         * The index of which day to start the week on, based on the Locale#weekdays array.
         * E.g. if the locale is en-us, weekStartIndex = 1 results in starting the week on monday.
         */
        this.weekStartIndex = 0;
        /**
         * Shows week numbers displayed on the left side of the date picker
         *
         * @since 3.0.0
         */
        this.showWeekNumbers = false;
        /** @internal */
        this.embedded = false;
        /** @internal */
        this.today = DateTime.now().toISO();
        this.selectedYear = 0;
        this.tempYear = 0;
        this.startYear = 0;
        this.endYear = 0;
        this.selectedMonth = 0;
        this.tempMonth = 0;
        this.dropdownButtonRef = makeRef();
        this.yearContainerRef = makeRef();
        this.firstMonthRef = makeRef();
        this.focusedDay = 1;
        this.isDayFocus = false;
        this.monthChangedFromFocus = false;
        this.DAYS_IN_WEEK = 7;
        this.calendar = [];
    }
    watchFromPropHandler(newValue) {
        if (!newValue) {
            this.currFromDate = undefined;
            return;
        }
        const date = this.parseDateString(newValue);
        if (date) {
            this.currFromDate = date;
            this.updateSelectedYearMonth(date);
        }
    }
    watchToPropHandler(newValue) {
        if (!newValue) {
            this.currToDate = undefined;
            return;
        }
        const date = this.parseDateString(newValue);
        if (date) {
            this.currToDate = date;
            this.updateSelectedYearMonth(date);
        }
    }
    onLocaleChange() {
        this.setTranslations();
    }
    /**
     * Get the currently selected date or range. The object returned contains `from` and `to` properties.
     * The property strings are formatted according to the `format` property and not affected by the `locale` property.
     * The locale applied is always `en-US`.
     */
    async getCurrentDate() {
        var _a, _b, _c, _d;
        const _from = ((_a = this.currFromDate) === null || _a === void 0 ? void 0 : _a.isValid)
            ? (_b = this.currFromDate) === null || _b === void 0 ? void 0 : _b.toFormat(this.format)
            : undefined;
        const _to = ((_c = this.currToDate) === null || _c === void 0 ? void 0 : _c.isValid)
            ? (_d = this.currToDate) === null || _d === void 0 ? void 0 : _d.toFormat(this.format)
            : undefined;
        if (!this.singleSelection) {
            return {
                from: _from,
                to: _to,
            };
        }
        return {
            from: _from,
            to: undefined,
        };
    }
    handleKeyUp(event) {
        if (!this.isDayFocus) {
            return;
        }
        let _focusedDay = this.focusedDay;
        switch (event.key) {
            case 'ArrowLeft':
                _focusedDay--;
                break;
            case 'ArrowRight':
                _focusedDay++;
                break;
            case 'ArrowUp':
                _focusedDay = _focusedDay - 7;
                break;
            case 'ArrowDown':
                _focusedDay = _focusedDay + 7;
                break;
            default:
                return;
        }
        if (_focusedDay > this.getDaysInCurrentMonth()) {
            _focusedDay = _focusedDay - this.getDaysInCurrentMonth();
            this.changeToAdjacentMonth(1);
            this.monthChangedFromFocus = true;
        }
        else if (_focusedDay < 1) {
            this.changeToAdjacentMonth(-1);
            _focusedDay = _focusedDay + this.getDaysInCurrentMonth();
            this.monthChangedFromFocus = true;
        }
        this.focusedDay = _focusedDay;
    }
    getDaysInCurrentMonth() {
        return (DateTime.utc(this.selectedYear, this.selectedMonth + 1).daysInMonth || 0);
    }
    getDateTimeNow() {
        return DateTime.fromISO(this.today);
    }
    parseDateString(dateString) {
        const date = DateTime.fromFormat(dateString, this.format);
        if (!date.isValid) {
            console.error(date.invalidExplanation);
            return undefined;
        }
        return date;
    }
    updateSelectedYearMonth(date) {
        this.selectedYear = date.year;
        this.selectedMonth = date.month - 1;
    }
    onDayBlur() {
        this.isDayFocus = false;
    }
    onDayFocus() {
        this.isDayFocus = true;
    }
    componentWillLoad() {
        var _a, _b, _c, _d;
        this.setTranslations();
        this.currFromDate = this.from
            ? DateTime.fromFormat(this.from, this.format)
            : undefined;
        this.currToDate = this.to
            ? DateTime.fromFormat(this.to, this.format)
            : undefined;
        const year = (_b = (_a = this.currFromDate) === null || _a === void 0 ? void 0 : _a.year) !== null && _b !== void 0 ? _b : this.getDateTimeNow().year;
        this.startYear = year - 5;
        this.endYear = year + 5;
        this.selectedMonth =
            ((_d = (_c = this.currFromDate) === null || _c === void 0 ? void 0 : _c.month) !== null && _d !== void 0 ? _d : this.getDateTimeNow().month) - 1;
        this.selectedYear = year;
        this.tempMonth = this.selectedMonth;
        this.tempYear = this.selectedYear;
    }
    componentWillRender() {
        this.calculateCalendar();
    }
    componentDidRender() {
        if (!this.monthChangedFromFocus && !this.isDayFocus) {
            return;
        }
        const dayElem = this.hostElement.shadowRoot.querySelector(`[id=day-cell-${this.focusedDay}]`);
        dayElem.focus();
    }
    setTranslations() {
        this.dayNames = this.rotateWeekDayNames(Info.weekdays('long', {
            locale: this.locale,
        }), this.weekStartIndex);
        this.monthNames = Info.months('long', {
            locale: this.locale,
        });
    }
    /**
     * Rotate the WeekdayNames array.
     * Based on the position that should be the new 0-index.
     */
    rotateWeekDayNames(weekdays, index) {
        const clone = [...weekdays];
        if (index === 0) {
            return clone;
        }
        index = -index;
        const len = weekdays.length;
        clone.push(...clone.splice(0, ((-index % len) + len) % len));
        return clone;
    }
    async onDone() {
        const date = await this.getCurrentDate();
        this.dateSelect.emit(date);
    }
    calculateCalendar() {
        const calendar = [];
        const month = DateTime.utc(this.selectedYear, this.selectedMonth + 1);
        const monthStart = month.startOf('month');
        const monthEnd = month.endOf('month');
        let startWeek = monthStart.weekNumber;
        let endWeek = monthEnd.weekNumber;
        let monthStartWeekDayIndex = monthStart.weekday - 1;
        let monthEndWeekDayIndex = monthEnd.weekday - 1;
        if (this.weekStartIndex !== 0) {
            // Find the positions where to start/stop counting the day-numbers based on which day the week starts
            const weekdays = Info.weekdays();
            const monthStartWeekDayName = weekdays[monthStart.weekday];
            monthStartWeekDayIndex = this.dayNames.findIndex((d) => d === monthStartWeekDayName);
            const monthEndWeekDayName = weekdays[monthEnd.weekday];
            monthEndWeekDayIndex = this.dayNames.findIndex((d) => d === monthEndWeekDayName);
        }
        let correctLastWeek = false;
        if (endWeek === 1) {
            endWeek = monthEnd.weeksInWeekYear + 1;
            correctLastWeek = true;
        }
        let correctFirstWeek = false;
        if (startWeek === monthStart.weeksInWeekYear) {
            startWeek = 1;
            endWeek++;
            correctFirstWeek = true;
        }
        let currDayNumber = 1;
        for (let weekIndex = startWeek; weekIndex <= endWeek && currDayNumber <= 31; weekIndex++) {
            const daysArr = [];
            for (let j = 0; j < this.DAYS_IN_WEEK && currDayNumber <= 31; j++) {
                // Display empty cells until the calender starts/has ended
                if ((weekIndex === startWeek && j < monthStartWeekDayIndex) ||
                    (weekIndex === endWeek && j > monthEndWeekDayIndex)) {
                    daysArr.push(undefined);
                }
                else {
                    daysArr.push(currDayNumber++);
                }
            }
            if (correctFirstWeek || correctLastWeek) {
                if (weekIndex === 1) {
                    calendar.push({
                        weekNumber: monthStart.weeksInWeekYear,
                        dayNumbers: daysArr,
                    });
                }
                else if (weekIndex === monthEnd.weekNumber) {
                    calendar.push({
                        weekNumber: 1,
                        dayNumbers: daysArr,
                    });
                }
                else {
                    calendar.push({
                        weekNumber: weekIndex - 1,
                        dayNumbers: daysArr,
                    });
                }
                continue;
            }
            calendar.push({
                weekNumber: weekIndex,
                dayNumbers: daysArr,
            });
        }
        this.calendar = calendar;
    }
    selectTempYear(event, year) {
        event === null || event === void 0 ? void 0 : event.stopPropagation();
        this.tempYear = year;
    }
    focusMonth() {
        var _a;
        (_a = this.firstMonthRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
    infiniteScrollYears() {
        const yearContainer = this.yearContainerRef.current;
        if (!yearContainer) {
            return;
        }
        const scroll = yearContainer.scrollTop;
        const maxScroll = yearContainer.scrollHeight;
        const atTop = scroll === 0;
        const atBottom = Math.round(scroll + yearContainer.offsetHeight) >= maxScroll;
        const limit = 200;
        if (this.endYear - this.startYear > limit)
            return;
        if (atTop) {
            const first = yearContainer.firstElementChild;
            this.startYear -= 5;
            yearContainer.scrollTo(0, first.offsetTop);
            return;
        }
        if (atBottom) {
            const last = yearContainer.lastElementChild;
            this.endYear += 5;
            yearContainer.scrollTo(0, last.offsetTop);
        }
    }
    selectMonth(month) {
        this.selectedMonth = month;
        this.selectedYear = this.tempYear;
        this.tempMonth = month;
        const dropdown = this.hostElement.shadowRoot.querySelector('ix-dropdown');
        if (dropdown) {
            dropdown.show = false;
        }
    }
    changeToAdjacentMonth(number) {
        if (this.selectedMonth + number < 0) {
            this.selectedYear--;
            this.selectedMonth = 11;
        }
        else if (this.selectedMonth + number > 11) {
            this.selectedYear++;
            this.selectedMonth = 0;
        }
        else {
            this.selectedMonth += number;
        }
    }
    selectDay(selectedDay, target) {
        if (target.classList.contains('disabled')) {
            return;
        }
        const date = DateTime.fromJSDate(new Date(this.selectedYear, this.selectedMonth, selectedDay));
        if (this.singleSelection || this.currFromDate === undefined) {
            this.currFromDate = date;
            this.onDateChange();
            return;
        }
        // Reset the range selection
        if (this.currToDate !== undefined) {
            this.currFromDate = date;
            this.currToDate = undefined;
            this.onDateChange();
            return;
        }
        // Swap from/to if the second date is before the current date
        if (date < this.currFromDate) {
            this.currToDate = this.currFromDate;
            this.currFromDate = date;
            this.onDateChange();
            return;
        }
        // Set the range normally
        this.currToDate = date;
        this.onDateChange();
    }
    onDateChange() {
        this.getCurrentDate().then((date) => {
            this.dateChange.emit(date);
            if (!this.singleSelection) {
                this.dateRangeChange.emit(date);
            }
        });
    }
    getDayClasses(day) {
        var _a, _b, _c;
        const todayObj = this.getDateTimeNow();
        const selectedDayObj = DateTime.fromJSDate(new Date(this.selectedYear, this.selectedMonth, day));
        return {
            'calendar-item': true,
            'empty-day': day === undefined,
            today: todayObj.hasSame(selectedDayObj, 'day'),
            selected: !!(((_a = this.currFromDate) === null || _a === void 0 ? void 0 : _a.hasSame(selectedDayObj, 'day')) ||
                ((_b = this.currToDate) === null || _b === void 0 ? void 0 : _b.hasSame(selectedDayObj, 'day'))),
            range: !!(this.currFromDate &&
                selectedDayObj.startOf('day') > this.currFromDate.startOf('day') &&
                this.currToDate !== undefined &&
                selectedDayObj.startOf('day') < ((_c = this.currToDate) === null || _c === void 0 ? void 0 : _c.startOf('day'))),
            disabled: !this.isWithinMinMaxDate(selectedDayObj),
        };
    }
    isWithinMinMaxYear(year) {
        const minDateYear = this.minDate
            ? DateTime.fromFormat(this.minDate, this.format).year
            : undefined;
        const maxDateYear = this.maxDate
            ? DateTime.fromFormat(this.maxDate, this.format).year
            : undefined;
        const isBefore = minDateYear ? year < minDateYear : false;
        const isAfter = maxDateYear ? year > maxDateYear : false;
        return !isBefore && !isAfter;
    }
    isWithinMinMaxMonth(month) {
        const minDateObj = this.minDate
            ? DateTime.fromFormat(this.minDate, this.format)
            : undefined;
        const maxDateObj = this.maxDate
            ? DateTime.fromFormat(this.maxDate, this.format)
            : undefined;
        const minDateMonth = minDateObj === null || minDateObj === void 0 ? void 0 : minDateObj.month;
        const maxDateMonth = maxDateObj === null || maxDateObj === void 0 ? void 0 : maxDateObj.month;
        const isBefore = minDateMonth
            ? this.tempYear === minDateObj.year && month < minDateMonth
            : false;
        const isAfter = maxDateMonth
            ? this.tempYear === maxDateObj.year && month > maxDateMonth
            : false;
        return !isBefore && !isAfter;
    }
    isWithinMinMaxDate(date) {
        const _minDate = this.minDate
            ? DateTime.fromFormat(this.minDate, this.format)
            : undefined;
        const _maxDate = this.maxDate
            ? DateTime.fromFormat(this.maxDate, this.format)
            : undefined;
        const isBefore = _minDate
            ? date.startOf('day') < _minDate.startOf('day')
            : false;
        const isAfter = _maxDate
            ? date.startOf('day') > _maxDate.startOf('day')
            : false;
        return !isBefore && !isAfter;
    }
    renderYears() {
        const rows = [];
        for (let year = this.startYear; year <= this.endYear; year++) {
            rows.push(h("div", { key: year, class: {
                    arrowYear: true,
                    'month-dropdown-item': true,
                    'disabled-item': !this.isWithinMinMaxYear(year),
                }, onClick: (event) => this.selectTempYear(event, year), onKeyUp: (event) => {
                    if (event.key === 'Enter') {
                        this.tempYear = year;
                        this.focusMonth();
                    }
                }, tabIndex: 0 }, h("ix-icon", { class: {
                    hidden: this.tempYear !== year,
                    arrowPosition: true,
                }, name: iconChevronRightSmall, size: "12" }), h("div", { style: { 'min-width': 'max-content' } }, `${year}`)));
        }
        return rows;
    }
    render() {
        return (h(Host, { key: 'ac385bc586d47db0ce5aeb9eab3e7e71e71fe7cf' }, h("ix-date-time-card", { key: 'e1d11ba64aa8b1374c6ded705afa779a9b3966b1', corners: this.corners, embedded: this.embedded }, h("div", { key: 'bc99b5e074709ee8599799814a3bc7fd5ab417a5', class: "header", slot: "header" }, h("ix-icon-button", { key: '6bc172523c9588a3bb1d200d5113b2533117c021', onClick: () => this.changeToAdjacentMonth(-1), icon: iconChevronLeftSmall, variant: "tertiary", class: "arrows", "aria-label": this.ariaLabelPreviousMonthButton }), h("div", { key: 'e3505b87752b9d763ba61286f1091e67e2ee3314', class: "selector" }, h("ix-button", { key: 'f6740c7a4ea82875e876896ab0d311e56edf2c6d', variant: "tertiary", ref: this.dropdownButtonRef, "data-testid": "year-month-button" }, h("span", { key: '0cd1e04f63512e2c8798d3524c2e8cc3e719d853', class: "capitalize" }, this.monthNames[this.selectedMonth], " ", this.selectedYear)), h("ix-dropdown", { key: '0021b8af9b8ba6b23e9ed49ebb4edcecc55eeb26', "data-testid": "year-month-dropdown", class: "dropdown", trigger: this.dropdownButtonRef.waitForCurrent(), ignoreRelatedSubmenu: true, placement: "bottom-start" }, h("div", { key: 'f00cf88696bec06c49c59962d3dcb4838be3f3f2', class: "wrapper" }, h("div", { key: '0d6b2ca0c9a2f23a7fd1fa24cc05454da9e16af7', "data-testid": "year-container", class: "overflow", onScroll: () => this.infiniteScrollYears(), ref: this.yearContainerRef }, this.renderYears()), h("div", { key: 'bff068918a1f31e25f1d22b9e2f4b36e0a2affdd', class: "overflow", "data-testid": "month-container" }, this.monthNames.map((month, index) => (h("div", { key: month, ref: (ref) => {
                if (month === this.monthNames[0]) {
                    this.firstMonthRef(ref);
                }
            }, class: {
                arrowYear: true,
                'month-dropdown-item': true,
                selected: this.tempYear === this.selectedYear &&
                    this.tempMonth === index,
                'disabled-item': !this.isWithinMinMaxMonth(index),
            }, onClick: () => this.selectMonth(index), onKeyUp: (event) => event.key === 'Enter' && this.selectMonth(index), tabIndex: 0 }, h("ix-icon", { class: {
                hidden: this.tempYear !== this.selectedYear ||
                    this.tempMonth !== index,
                checkPosition: true,
            }, name: iconSingleCheck, size: "16" }), h("div", null, h("span", { class: "capitalize monthMargin" }, `${month} ${this.tempYear}`))))))))), h("ix-icon-button", { key: '42af554f8f382640b60f98b68708e5cb4912bf33', onClick: () => this.changeToAdjacentMonth(1), icon: iconChevronRightSmall, variant: "tertiary", class: "arrows", "aria-label": this.ariaLabelNextMonthButton })), h("div", { key: '565551cf265951458d43742f5a64e1d3e8107bcc', class: {
                grid: true,
                'grid--show-week-numbers': this.showWeekNumbers,
            } }, this.showWeekNumbers && h("div", { key: '153664ce89e84909f75d424f3af985f3c8caa22b', class: "calendar-item week-day" }), this.dayNames.map((name) => (h("div", { key: name, class: "calendar-item week-day" }, h("div", { class: "overflow" }, name.slice(0, 3))))), this.calendar.map((week) => {
            return (h(Fragment, null, this.showWeekNumbers && (h("div", { class: "calendar-item week-number" }, week.weekNumber)), week.dayNumbers.map((day) => {
                return day ? (h("div", { key: day, id: `day-cell-${day}`, "date-calender-day": true, class: this.getDayClasses(day), onClick: (e) => {
                        const target = e.currentTarget;
                        this.selectDay(day, target);
                    }, onKeyUp: (e) => {
                        const target = e.currentTarget;
                        if (e.key === 'Enter') {
                            this.selectDay(day, target);
                        }
                    }, tabIndex: day === this.focusedDay ? 0 : -1, onFocus: () => this.onDayFocus(), onBlur: () => this.onDayBlur(), "aria-label": `${this.selectedMonth}: ${day}` }, day)) : (h("div", null));
            })));
        })), h("div", { key: 'a3eaf5affbf21d93ac0bd2938a544e372ecee2bc', class: {
                button: true,
                hidden: this.singleSelection || this.embedded,
            } }, h("ix-button", { key: 'bcbc94626760a7c8e755f4afb52f127d5b49dcd7', onClick: () => this.onDone() }, this.i18nDone)))));
    }
    static get is() { return "ix-date-picker"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["date-picker.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["date-picker.css"]
        };
    }
    static get properties() {
        return {
            "format": {
                "type": "string",
                "attribute": "format",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Date format string.\nSee {@link https://moment.github.io/luxon/#/formatting?id=table-of-tokens} for all available tokens."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'yyyy/LL/dd'"
            },
            "singleSelection": {
                "type": "boolean",
                "attribute": "single-selection",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "If true disables date range selection (from/to)."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "corners": {
                "type": "string",
                "attribute": "corners",
                "mutable": false,
                "complexType": {
                    "original": "DateTimeCardCorners",
                    "resolved": "\"left\" | \"right\" | \"rounded\" | \"straight\"",
                    "references": {
                        "DateTimeCardCorners": {
                            "location": "import",
                            "path": "../date-time-card/date-time-card.types",
                            "id": "src/components/date-time-card/date-time-card.types.ts::DateTimeCardCorners"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Corner style"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'rounded'"
            },
            "from": {
                "type": "string",
                "attribute": "from",
                "mutable": false,
                "complexType": {
                    "original": "string | undefined",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The selected starting date. If the date-picker-rework is not in range mode this is the selected date.\nFormat has to match the `format` property."
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "to": {
                "type": "string",
                "attribute": "to",
                "mutable": false,
                "complexType": {
                    "original": "string | undefined",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The selected end date. If the the date-picker-rework is not in range mode this property has no impact.\nFormat has to match the `format` property."
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "minDate": {
                "type": "string",
                "attribute": "min-date",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The earliest date that can be selected by the date picker.\nIf not set there will be no restriction."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "''"
            },
            "maxDate": {
                "type": "string",
                "attribute": "max-date",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The latest date that can be selected by the date picker.\nIf not set there will be no restriction."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "''"
            },
            "i18nDone": {
                "type": "string",
                "attribute": "i18n-done",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Text of date select button"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "'Done'"
            },
            "ariaLabelPreviousMonthButton": {
                "type": "string",
                "attribute": "aria-label-previous-month-button",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "ARIA label for the previous month icon button\nWill be set as aria-label on the nested HTML button element"
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "ariaLabelNextMonthButton": {
                "type": "string",
                "attribute": "aria-label-next-month-button",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "ARIA label for the next month icon button\nWill be set as aria-label on the nested HTML button element"
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "weekStartIndex": {
                "type": "number",
                "attribute": "week-start-index",
                "mutable": false,
                "complexType": {
                    "original": "number",
                    "resolved": "number",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The index of which day to start the week on, based on the Locale#weekdays array.\nE.g. if the locale is en-us, weekStartIndex = 1 results in starting the week on monday."
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "0"
            },
            "locale": {
                "type": "string",
                "attribute": "locale",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Locale identifier (e.g. 'en' or 'de').\nThe locale is used to translate the labels for weekdays and months.\nIt also determines the default order of weekdays based on the locale's conventions.\nWhen the locale changes, the weekday labels are rotated according to the `weekStartIndex`.\nIt does not affect the values returned by methods and events."
                },
                "getter": false,
                "setter": false,
                "reflect": false
            },
            "showWeekNumbers": {
                "type": "boolean",
                "attribute": "show-week-numbers",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "since",
                            "text": "3.0.0"
                        }],
                    "text": "Shows week numbers displayed on the left side of the date picker"
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "embedded": {
                "type": "boolean",
                "attribute": "embedded",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "false"
            },
            "today": {
                "type": "string",
                "attribute": "today",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [{
                            "name": "internal",
                            "text": undefined
                        }],
                    "text": ""
                },
                "getter": false,
                "setter": false,
                "reflect": false,
                "defaultValue": "DateTime.now().toISO()"
            }
        };
    }
    static get states() {
        return {
            "currFromDate": {},
            "currToDate": {},
            "selectedYear": {},
            "tempYear": {},
            "startYear": {},
            "endYear": {},
            "selectedMonth": {},
            "tempMonth": {},
            "dayNames": {},
            "monthNames": {},
            "focusedDay": {}
        };
    }
    static get events() {
        return [{
                "method": "dateChange",
                "name": "dateChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the date selection changes. The `DateChangeEvent` contains `from` and `to` properties.\nThe property strings are formatted according to the `format` property and not affected by the `locale` property.\nThe locale applied is always `en-US`.\nNote: Since 2.0.0 `dateChange` does not dispatch detail property as `string`"
                },
                "complexType": {
                    "original": "DateChangeEvent",
                    "resolved": "{ from?: string | undefined; to?: string | undefined; }",
                    "references": {
                        "DateChangeEvent": {
                            "location": "import",
                            "path": "./date-picker.events",
                            "id": "src/components/date-picker/date-picker.events.ts::DateChangeEvent"
                        }
                    }
                }
            }, {
                "method": "dateRangeChange",
                "name": "dateRangeChange",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the date range selection changes and the component is in range mode. The `DateChangeEvent` contains `from` and `to` properties.\nThe property strings are formatted according to the `format` property and not affected by the `locale` property.\nThe locale applied is always `en-US`."
                },
                "complexType": {
                    "original": "DateChangeEvent",
                    "resolved": "{ from?: string | undefined; to?: string | undefined; }",
                    "references": {
                        "DateChangeEvent": {
                            "location": "import",
                            "path": "./date-picker.events",
                            "id": "src/components/date-picker/date-picker.events.ts::DateChangeEvent"
                        }
                    }
                }
            }, {
                "method": "dateSelect",
                "name": "dateSelect",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "Emitted when the selection is confirmed via the date select button. The `DateChangeEvent` contains `from` and `to` properties.\nThe property strings are formatted according to the `format` property and not affected by the `locale` property.\nThe locale applied is always `en-US`."
                },
                "complexType": {
                    "original": "DateChangeEvent",
                    "resolved": "{ from?: string | undefined; to?: string | undefined; }",
                    "references": {
                        "DateChangeEvent": {
                            "location": "import",
                            "path": "./date-picker.events",
                            "id": "src/components/date-picker/date-picker.events.ts::DateChangeEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "getCurrentDate": {
                "complexType": {
                    "signature": "() => Promise<DateChangeEvent>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "DateChangeEvent": {
                            "location": "import",
                            "path": "./date-picker.events",
                            "id": "src/components/date-picker/date-picker.events.ts::DateChangeEvent"
                        }
                    },
                    "return": "Promise<DateChangeEvent>"
                },
                "docs": {
                    "text": "Get the currently selected date or range. The object returned contains `from` and `to` properties.\nThe property strings are formatted according to the `format` property and not affected by the `locale` property.\nThe locale applied is always `en-US`.",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "hostElement"; }
    static get watchers() {
        return [{
                "propName": "from",
                "methodName": "watchFromPropHandler"
            }, {
                "propName": "to",
                "methodName": "watchToPropHandler"
            }, {
                "propName": "locale",
                "methodName": "onLocaleChange"
            }];
    }
}
__decorate([
    OnListener('keydown')
], DatePicker.prototype, "handleKeyUp", null);
//# sourceMappingURL=date-picker.js.map

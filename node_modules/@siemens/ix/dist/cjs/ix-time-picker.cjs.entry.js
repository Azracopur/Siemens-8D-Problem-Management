'use strict';

var index = require('./index-C8Xo8L1k.js');
var datetime = require('./datetime-Dvtv5O8f.js');
var listener = require('./listener-OBCpw0Y2.js');

const timePickerCss = ".ix-form-control,.ix-form-control-plaintext{color:var(--theme-input--color);border-radius:var(--theme-input--border-radius);height:2rem;min-height:2rem;min-width:2rem;background-color:var(--theme-input--background);border:solid 1px var(--theme-input--border-color);box-shadow:var(--theme-input--box-shadow);padding-inline-start:0.5rem;padding-inline-end:0.5rem;font-family:Siemens Sans, sans-serif;font-size:0.875rem;font-weight:400;line-height:1.429em;color:var(--theme-color-std-text);-webkit-font-smoothing:antialiased;-moz-osx-font-smooting:grayscale;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ix-form-control::-moz-placeholder,.ix-form-control-plaintext::-moz-placeholder{color:var(--theme-input-hint--color)}.ix-form-control::placeholder,.ix-form-control-plaintext::placeholder{color:var(--theme-input-hint--color)}.ix-form-control:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled),.ix-form-control-plaintext:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled){cursor:pointer}.ix-form-control:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled),.ix-form-control-plaintext:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled){cursor:pointer}.ix-form-control:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):hover,.ix-form-control:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled).hover,.ix-form-control-plaintext:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):hover,.ix-form-control-plaintext:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled).hover{background-color:var(--theme-input--background--hover);border-color:var(--theme-input--border-color--hover);cursor:auto}.ix-form-control:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):hover,.ix-form-control:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled).hover,.ix-form-control-plaintext:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):hover,.ix-form-control-plaintext:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled).hover{background-color:var(--theme-input--background--hover);border-color:var(--theme-input--border-color--hover);cursor:auto}.ix-form-control:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):focus-visible,.ix-form-control-plaintext:not(:-moz-read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):focus-visible{background-color:var(--theme-input--background--focus);border-color:var(--theme-input--border-color--focus);outline-offset:var(--theme-input--focus--outline-offset);box-shadow:var(--theme-input--box-shadow);outline:1px solid var(--theme-color-focus-bdr)}.ix-form-control:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):focus-visible,.ix-form-control-plaintext:not(:read-only):not([readonly]):not([readOnly]):not(.readonly):not(.disabled):not(:disabled):focus-visible{background-color:var(--theme-input--background--focus);border-color:var(--theme-input--border-color--focus);outline-offset:var(--theme-input--focus--outline-offset);box-shadow:var(--theme-input--box-shadow);outline:1px solid var(--theme-color-focus-bdr)}.ix-form-control:focus-visible{color:var(--theme-input--color)}.ix-form-control[type=number]::-webkit-inner-spin-button{margin-right:-2px;margin-left:2px;display:none}.ix-form-control[type=number]{text-align:right}.ix-form-control.readonly,.ix-form-control[readonly]{background:transparent !important;border-block-start:none !important;border-inline-start:none !important;border-inline-end:none !important;border-radius:0rem}.ix-form-control:-moz-read-only{box-shadow:none !important;outline:none !important;border-color:var(--theme-input--border-color);cursor:default !important}.ix-form-control:read-only,.ix-form-control[readonly],.ix-form-control[readOnly],.ix-form-control.readonly{box-shadow:none !important;outline:none !important;border-color:var(--theme-input--border-color);cursor:default !important}.ix-form-control:read-only::-moz-placeholder,.ix-form-control[readonly]::-moz-placeholder,.ix-form-control[readOnly]::-moz-placeholder,.ix-form-control.readonly::-moz-placeholder{color:transparent}.ix-form-control:-moz-read-only::placeholder{color:transparent}.ix-form-control:read-only::placeholder,.ix-form-control[readonly]::placeholder,.ix-form-control[readOnly]::placeholder,.ix-form-control.readonly::placeholder{color:transparent}.ix-form-control:disabled,.ix-form-control.disabled{background:transparent !important;border-block-start:none !important;border-inline-start:none !important;border-inline-end:none !important;border-radius:0rem;color:var(--theme-color-weak-text);border-color:var(--theme-input--border-color-bottom--disabled)}.ix-form-control:disabled::-moz-placeholder,.ix-form-control.disabled::-moz-placeholder{color:transparent}.ix-form-control:disabled::placeholder,.ix-form-control.disabled::placeholder{color:transparent}.ix-form-control-plaintext{outline:0}.form-group{position:relative}.input-wrapper{display:flex;position:relative;align-items:center;flex-wrap:nowrap}.input-wrapper>.glyph{display:block;position:absolute;margin-inline-start:0.312rem;color:var(--theme-color-std-text)}.input-wrapper>input{padding-inline-start:2.2rem}select.ix-form-control{padding:0 0.312rem}textarea.ix-form-control{padding:0.375rem 0.5rem}input.ix-form-control.disabled,input.ix-form-control:disabled{color:var(--theme-input--color--disabled)}input.ix-form-control:-moz-read-only{cursor:default}input.ix-form-control:read-only,input.ix-form-control.readonly{cursor:default}input{min-height:2rem;width:auto;padding:0.25rem 0.5rem;background-color:var(--theme-input--background);color:var(--theme-input--color);-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;text-overflow:ellipsis;border:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color);border-radius:var(--theme-input--border-radius);box-shadow:var(--theme-input--box-shadow);font-feature-settings:\"clig\" off, \"liga\" off;font-family:Siemens Sans, Siemens Sans, Arial, Helvetica, sans-serif;font-style:normal;font-size:var(--theme-ms-0);line-height:var(--theme-line-height-md);font-weight:var(--theme-font-weight-normal);letter-spacing:var(--theme-letter-spacing-xl);text-decoration:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smooting:grayscale}input[type=number]{text-align:right}input[type=number]::-webkit-inner-spin-button{margin-right:-2px;margin-left:2px;display:none}input:-webkit-autofill{-webkit-box-shadow:0 0 0 1000px var(--theme-color-component-info) inset !important;-webkit-text-fill-color:var(--theme-input--color--autofill) !important;background-color:var(--theme-input--background--autofill) !important;border:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color--autofill) !important;color:var(--theme-input--color--autofill) !important}input:-webkit-autofill,input:autofill{-webkit-box-shadow:0 0 0 1000px var(--theme-color-component-info) inset !important;-webkit-text-fill-color:var(--theme-input--color--autofill) !important;background-color:var(--theme-input--background--autofill) !important;border:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color--autofill) !important;color:var(--theme-input--color--autofill) !important}input::-moz-placeholder{color:var(--theme-input-hint--color)}input::placeholder{color:var(--theme-input-hint--color)}input.hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only),input:hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only){border-color:var(--theme-input--border-color--hover) !important;background-color:var(--theme-input--background--hover)}input.hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only),input:hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only){border-color:var(--theme-input--border-color--hover) !important;background-color:var(--theme-input--background--hover)}input.focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only),input:focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only){outline:1px solid var(--theme-color-focus-bdr);outline-offset:var(--theme-input--focus--outline-offset);border-color:var(--theme-input--border-color--focus) !important}input.focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only),input:focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only){outline:1px solid var(--theme-color-focus-bdr);outline-offset:var(--theme-input--focus--outline-offset);border-color:var(--theme-input--border-color--focus) !important}input:-moz-read-only{box-shadow:none;background-color:transparent;outline:none;border:none;border-radius:0;border-bottom:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color-bottom--readonly)}input.read-only,input:read-only{box-shadow:none;background-color:transparent;outline:none;border:none;border-radius:0;border-bottom:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color-bottom--readonly)}input.read-only::-moz-placeholder,input:read-only::-moz-placeholder{color:transparent}input:-moz-read-only::placeholder{color:transparent}input.read-only::placeholder,input:read-only::placeholder{color:transparent}input:disabled,input.disabled{box-shadow:none;background-color:transparent;outline:none;border:none;border-radius:0;color:var(--theme-input--color--disabled);border-bottom:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color-bottom--disabled)}input:disabled::-moz-placeholder,input.disabled::-moz-placeholder{color:transparent}input:disabled::placeholder,input.disabled::placeholder{color:transparent}textarea{min-height:2rem;width:auto;padding:0.25rem 0.5rem;background-color:var(--theme-input--background);color:var(--theme-input--color);-webkit-appearance:textfield;-moz-appearance:textfield;appearance:textfield;text-overflow:ellipsis;border:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color);border-radius:var(--theme-input--border-radius);box-shadow:var(--theme-input--box-shadow);font-feature-settings:\"clig\" off, \"liga\" off;font-family:Siemens Sans, Siemens Sans, Arial, Helvetica, sans-serif;font-style:normal;font-size:var(--theme-ms-0);line-height:var(--theme-line-height-md);font-weight:var(--theme-font-weight-normal);letter-spacing:var(--theme-letter-spacing-xl);text-decoration:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smooting:grayscale}textarea[type=number]{text-align:right}textarea[type=number]::-webkit-inner-spin-button{margin-right:-2px;margin-left:2px;display:none}textarea:-webkit-autofill{-webkit-box-shadow:0 0 0 1000px var(--theme-color-component-info) inset !important;-webkit-text-fill-color:var(--theme-input--color--autofill) !important;background-color:var(--theme-input--background--autofill) !important;border:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color--autofill) !important;color:var(--theme-input--color--autofill) !important}textarea:-webkit-autofill,textarea:autofill{-webkit-box-shadow:0 0 0 1000px var(--theme-color-component-info) inset !important;-webkit-text-fill-color:var(--theme-input--color--autofill) !important;background-color:var(--theme-input--background--autofill) !important;border:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color--autofill) !important;color:var(--theme-input--color--autofill) !important}textarea::-moz-placeholder{color:var(--theme-input-hint--color)}textarea::placeholder{color:var(--theme-input-hint--color)}textarea.hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only),textarea:hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only){border-color:var(--theme-input--border-color--hover) !important;background-color:var(--theme-input--background--hover)}textarea.hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only),textarea:hover:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only){border-color:var(--theme-input--border-color--hover) !important;background-color:var(--theme-input--background--hover)}textarea.focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only),textarea:focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:-moz-read-only){outline:1px solid var(--theme-color-focus-bdr);outline-offset:var(--theme-input--focus--outline-offset);border-color:var(--theme-input--border-color--focus) !important}textarea.focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only),textarea:focus:not(.readonly,.read-only,.disabled,[readonly],[disabled],:read-only){outline:1px solid var(--theme-color-focus-bdr);outline-offset:var(--theme-input--focus--outline-offset);border-color:var(--theme-input--border-color--focus) !important}textarea:-moz-read-only{box-shadow:none;background-color:transparent;outline:none;border:none;border-radius:0;border-bottom:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color-bottom--readonly)}textarea.read-only,textarea:read-only{box-shadow:none;background-color:transparent;outline:none;border:none;border-radius:0;border-bottom:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color-bottom--readonly)}textarea.read-only::-moz-placeholder,textarea:read-only::-moz-placeholder{color:transparent}textarea:-moz-read-only::placeholder{color:transparent}textarea.read-only::placeholder,textarea:read-only::placeholder{color:transparent}textarea:disabled,textarea.disabled{box-shadow:none;background-color:transparent;outline:none;border:none;border-radius:0;color:var(--theme-input--color--disabled);border-bottom:var(--theme-input--border-thickness, 1px) solid var(--theme-input--border-color-bottom--disabled)}textarea:disabled::-moz-placeholder,textarea.disabled::-moz-placeholder{color:transparent}textarea:disabled::placeholder,textarea.disabled::placeholder{color:transparent}textarea{min-height:2rem;height:3.25rem;padding:calc(0.375rem - var(--theme-input--border-thickness)) calc(0.5rem - var(--theme-input--border-thickness))}textarea.ix-info:not(.disabled):not(:disabled):not([disabled]),input.ix-info:not(.disabled):not(:disabled):not([disabled]){border-color:var(--theme-input--border-color--info)}textarea.ix-info:not(.disabled):not(:disabled):not([disabled]):hover,input.ix-info:not(.disabled):not(:disabled):not([disabled]):hover{border-color:var(--theme-input--border-color--info--hover) !important}textarea.ix-info:not(.disabled):not(:disabled):not([disabled]):active,input.ix-info:not(.disabled):not(:disabled):not([disabled]):active{border-color:var(--theme-input--border-color--info--active) !important}textarea.ix-warning:not(.disabled):not(:disabled):not([disabled]),input.ix-warning:not(.disabled):not(:disabled):not([disabled]){background-color:var(--theme-input--background--warning);border-color:var(--theme-input--border-color--warning--active) !important}textarea.ix-warning:not(.disabled):not(:disabled):not([disabled]):hover,input.ix-warning:not(.disabled):not(:disabled):not([disabled]):hover{background-color:var(--theme-input--background--warning--hover);border-color:var(--theme-input--border-color--warning--hover) !important}textarea.ix-warning:not(.disabled):not(:disabled):not([disabled]):active,input.ix-warning:not(.disabled):not(:disabled):not([disabled]):active{border-color:var(--theme-input--border-color--warning--active) !important}textarea[class*=ix-invalid]:not(.disabled):not(:disabled):not([disabled]),input[class*=ix-invalid]:not(.disabled):not(:disabled):not([disabled]){background-color:var(--theme-input--background--invalid);border-color:var(--theme-input--border-color--invalid) !important}textarea[class*=ix-invalid]:not(.disabled):not(:disabled):not([disabled]):hover,input[class*=ix-invalid]:not(.disabled):not(:disabled):not([disabled]):hover{background-color:var(--theme-input--background--invalid--hover);border-color:var(--theme-input--border-color--invalid--hover) !important}textarea[class*=ix-invalid]:not(.disabled):not(:disabled):not([disabled]):active,input[class*=ix-invalid]:not(.disabled):not(:disabled):not([disabled]):active{border-color:var(--theme-input--border-color--invalid--active) !important}:host{display:block;position:relative;width:-moz-fit-content;width:fit-content}:host *,:host *::after,:host *::before{box-sizing:border-box}:host ::-webkit-scrollbar-button{display:none}@-moz-document url-prefix(){:host *{scrollbar-color:var(--theme-scrollbar-thumb--background) var(--theme-scrollbar-track--background);scrollbar-width:thin}}:host{}:host ::-webkit-scrollbar{width:0.5rem;height:0.5rem}:host{}:host ::-webkit-scrollbar-track{border-radius:5px;background:var(--theme-scrollbar-track--background)}:host ::-webkit-scrollbar-track:hover{background:var(--theme-scrollbar-track--background--hover)}:host{}:host ::-webkit-scrollbar-thumb{border-radius:5px;background:var(--theme-scrollbar-thumb--background)}:host{}:host ::-webkit-scrollbar-thumb:hover{background:var(--theme-scrollbar-thumb--background--hover)}:host ::-webkit-scrollbar-corner{display:none}:host .standaloneAppearance{box-shadow:none}:host .hidden{display:none}:host .header{display:flex;align-items:center;justify-content:center;height:2rem}:host .clock{display:flex;justify-content:center;align-items:start}:host .clock .flex{display:flex;height:100%;align-items:start}:host .clock .flex .columns{display:flex;flex-direction:column;align-items:center;justify-content:space-around}:host .clock .flex .columns .column-header{height:2.5rem;width:2.5rem;line-height:2.5rem;text-align:center;color:var(--theme-color-soft-text);text-overflow:ellipsis;overflow:hidden;white-space:nowrap}:host .clock .flex .column-separator{display:flex;align-items:center;justify-content:center;min-height:100%;margin-top:3rem;width:0.5rem}:host .clock .element-list{list-style-type:none;overflow:auto;padding:0.0625rem;margin:-0.0625rem;max-height:15.75rem}:host .clock .element-list button{all:unset}:host .clock .element-list .element-container{box-sizing:border-box;width:2.5rem;height:2.5rem;margin-bottom:0.125rem;display:flex;justify-content:center;align-items:center;cursor:pointer;color:var(--theme-color-primary)}:host .clock .element-list .element-container:hover{background-color:var(--theme-datepicker-day--background--hover)}:host .clock .element-list .element-container:focus-visible{box-shadow:0 0 0 1px var(--theme-color-focus-bdr)}:host .clock .element-list .selected{background-color:var(--theme-datepicker-day--background--selected);color:var(--theme-datepicker-day--color--selected);font-weight:var(--theme-font-weight-bold)}:host .clock .element-list .selected:hover{background-color:var(--theme-datepicker-day--background--selected-hover)}:host .clock .element-list .selected:focus-visible{border:0.0625rem solid var(--theme-color-inv-contrast-text)}:host .clock .element-list .element-list-padding{width:2.5rem;height:13.125rem;min-height:13.125rem}:host .clock div.element-list{scrollbar-width:none;-ms-overflow-style:none}:host .clock div.element-list::-webkit-scrollbar{display:none}:host .footer{display:flex;justify-content:space-between;gap:0.5rem;flex-wrap:wrap}:host .footer .confirm-button{margin-left:auto}:host .footer--compact{flex-direction:column;align-items:center}:host .footer--compact .confirm-button{margin-left:initial}:host .default-space{margin-left:1rem}:host .text-align{text-align:center}";

/*
 * SPDX-FileCopyrightText: 2023 Siemens AG
 *
 * SPDX-License-Identifier: MIT
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const LUXON_FORMAT_PATTERNS = {
    // h, hh, H, HH and various time formats that include hours
    hours: /\b[Hh]\b|HH|hh|H{3,4}|h{3,4}|t|tt|ttt|tttt|T|TT|TTT|TTTT/,
    // m, mm and time formats that include minutes
    minutes: /\bm\b|mm|t|tt|ttt|tttt|T|TT|TTT|TTTT/,
    // s, ss and time formats that include seconds
    seconds: /\bs\b|ss|tt|ttt|tttt|TT|TTT|TTTT/,
    // S, SSS (milliseconds), u/uu/uuu (fractional seconds), x/X (timestamps)
    milliseconds: /\bS\b|SSS|u|uu|uuu/,
};
const HOUR_INTERVAL_DEFAULT = 1;
const MINUTE_INTERVAL_DEFAULT = 1;
const SECOND_INTERVAL_DEFAULT = 1;
const MILLISECOND_INTERVAL_DEFAULT = 100;
const CONFIRM_BUTTON_DEFAULT = 'Confirm';
const HEADER_DEFAULT = 'Time';
const FORMATTED_TIME_EMPTY = {
    hour: '',
    minute: '',
    second: '',
    millisecond: '',
};
const TimePicker = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.timeSelect = index.createEvent(this, "timeSelect", 7);
        this.timeChange = index.createEvent(this, "timeChange", 7);
        /**
         * Format of time string
         * See {@link https://moment.github.io/luxon/#/formatting?id=table-of-tokens} for all available tokens.
         * Note: Formats that combine date and time (like f or F) are not supported. Timestamp tokens x and X are not supported either.
         */
        this.format = 'TT';
        /**
         * Corner style
         */
        this.corners = 'rounded';
        /**
         * Embedded style (for use in other components)
         */
        this.embedded = false;
        /**
         * @internal Temporary prop needed until datetime-picker is reworked for new design
         */
        this.dateTimePickerAppearance = false;
        /**
         * Hides the header of the picker.
         *
         * @since 3.2.0
         */
        this.hideHeader = false;
        /**
         * Interval for hour selection
         *
         * @since 3.2.0
         */
        this.hourInterval = HOUR_INTERVAL_DEFAULT;
        /**
         * Interval for minute selection
         *
         * @since 3.2.0
         */
        this.minuteInterval = MINUTE_INTERVAL_DEFAULT;
        /**
         * Interval for second selection
         *
         * @since 3.2.0
         */
        this.secondInterval = SECOND_INTERVAL_DEFAULT;
        /**
         * Interval for millisecond selection
         *
         * @since 3.2.0
         */
        this.millisecondInterval = MILLISECOND_INTERVAL_DEFAULT;
        /**
         * Text of the time confirm button
         */
        this.i18nConfirmTime = CONFIRM_BUTTON_DEFAULT;
        /**
         * Text for top header
         */
        this.i18nHeader = HEADER_DEFAULT;
        /**
         * Text for hour column header
         */
        this.i18nHourColumnHeader = 'hr';
        /**
         * Text for minute column header
         */
        // eslint-disable-next-line @stencil-community/decorators-style
        this.i18nMinuteColumnHeader = 'min';
        /**
         * Text for second column header
         */
        // eslint-disable-next-line @stencil-community/decorators-style
        this.i18nSecondColumnHeader = 'sec';
        /**
         * Text for millisecond column header
         */
        // eslint-disable-next-line @stencil-community/decorators-style
        this.i18nMillisecondColumnHeader = 'ms';
        this.formattedTime = FORMATTED_TIME_EMPTY;
        this.timePickerDescriptors = [];
        this.isUnitFocused = false;
        this.focusedUnit = 'hour';
        this.focusedValue = 0;
        this.focusScrollAlignment = 'start';
    }
    watchFormatIntervalPropHandler(newValue) {
        if (!newValue) {
            return;
        }
        this.initPicker();
        this.updateScrollPositions();
    }
    watchHourIntervalPropHandler(newValue) {
        if (Number.isInteger(newValue) &&
            newValue >= 0 &&
            newValue <= (this.timeRef ? 12 : 23)) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('hour', newValue);
        this.hourInterval = HOUR_INTERVAL_DEFAULT;
    }
    watchMinuteIntervalPropHandler(newValue) {
        if (newValue >= 0 && newValue <= 59) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('minute', newValue);
        this.minuteInterval = MINUTE_INTERVAL_DEFAULT;
    }
    watchSecondIntervalPropHandler(newValue) {
        if (newValue >= 0 && newValue <= 59) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('second', newValue);
        this.secondInterval = SECOND_INTERVAL_DEFAULT;
    }
    watchMillisecondIntervalPropHandler(newValue) {
        if (newValue >= 0 && newValue <= 999) {
            this.setTimePickerDescriptors();
            return;
        }
        this.printIntervalError('millisecond', newValue);
        this.millisecondInterval = MILLISECOND_INTERVAL_DEFAULT;
    }
    printIntervalError(intervalName, value) {
        console.error(`Value ${value} is not valid for ${intervalName}-interval. Falling back to default.`);
    }
    watchTimePropHandler(newValue) {
        const timeFormat = datetime.DateTime.fromFormat(newValue, this.format);
        if (!timeFormat.isValid) {
            throw new Error('Format is not supported or not correct');
        }
        this._time = timeFormat;
    }
    /**
     * Get default time value
     * @returns DateTime.now() for empty state (no selection)
     */
    getDefaultTime() {
        return datetime.DateTime.now();
    }
    /**
     * Get the current time based on the wanted format
     */
    async getCurrentTime() {
        var _a;
        return (_a = this._time) === null || _a === void 0 ? void 0 : _a.toFormat(this.format);
    }
    onTimeChange() {
        const formattedTimeOld = this.formattedTime;
        this.setTimeRef();
        this.formattedTime = this.getFormattedTime();
        this.updateScrollPositions(formattedTimeOld);
    }
    componentWillLoad() {
        this.initPicker();
    }
    initPicker() {
        let parsedTime;
        if (this.time) {
            parsedTime = datetime.DateTime.fromFormat(this.time, this.format);
            if (!parsedTime.isValid) {
                console.error(`Invalid time format. The configured format does not match the format of the passed time. ${parsedTime.invalidReason}: ${parsedTime.invalidExplanation}`);
                parsedTime = this.getDefaultTime();
            }
        }
        else {
            parsedTime = this.getDefaultTime();
        }
        this._time = parsedTime;
        this.setTimeRef();
        this.setTimePickerDescriptors();
        this.setInitialFocusedValueAndUnit();
        this.watchHourIntervalPropHandler(this.hourInterval);
        this.watchMinuteIntervalPropHandler(this.minuteInterval);
        this.watchSecondIntervalPropHandler(this.secondInterval);
        this.watchMillisecondIntervalPropHandler(this.millisecondInterval);
    }
    componentDidLoad() {
        this.updateScrollPositions();
        this.setupVisibilityObserver();
    }
    componentDidRender() {
        if (this.isUnitFocused) {
            const elementContainer = this.getElementContainer(this.focusedUnit, this.focusedValue);
            const elementList = this.getElementList(this.focusedUnit);
            if (elementContainer) {
                elementContainer.focus({ preventScroll: true });
                if (!this.isElementVisible(elementContainer, elementList)) {
                    this.scrollElementIntoView(elementContainer, elementList, this.focusScrollAlignment);
                }
            }
        }
    }
    disconnectedCallback() {
        if (this.visibilityObserver) {
            this.visibilityObserver.disconnect();
        }
    }
    handleKeyDown(event) {
        if (!this.isUnitFocused) {
            return;
        }
        let newValue = this.focusedValue;
        let shouldPreventDefault = true;
        let newValueInterval;
        switch (this.focusedUnit) {
            case 'hour':
                newValueInterval = this.hourInterval;
                break;
            case 'minute':
                newValueInterval = this.minuteInterval;
                break;
            case 'second':
                newValueInterval = this.secondInterval;
                break;
            case 'millisecond':
                newValueInterval = this.millisecondInterval;
                break;
        }
        switch (event.key) {
            case 'Tab':
                shouldPreventDefault = false;
                this.isUnitFocused = false;
                break;
            case 'ArrowUp':
                newValue -= newValueInterval;
                this.focusScrollAlignment = 'start';
                this.updateFocusedValue(newValue);
                this.updateDescriptorFocusedValue(this.focusedUnit, this.focusedValue);
                break;
            case 'ArrowDown':
                newValue += newValueInterval;
                this.focusScrollAlignment = 'end';
                this.updateFocusedValue(newValue);
                this.updateDescriptorFocusedValue(this.focusedUnit, this.focusedValue);
                break;
            case 'Enter':
            case ' ':
                this.select(this.focusedUnit, this.focusedValue);
                break;
            default:
                return;
        }
        if (shouldPreventDefault) {
            event.preventDefault();
        }
    }
    onUnitCellBlur(unit, event) {
        var _a;
        const relatedTarget = event.relatedTarget;
        // Check if column lost focus to scroll back to selected value
        if (relatedTarget) {
            const relatedUnit = (_a = relatedTarget.dataset.elementContainerId) === null || _a === void 0 ? void 0 : _a.split('-')[0];
            if (relatedUnit !== unit) {
                this.elementListScrollToTop(unit, Number(this.formattedTime[unit]), 'smooth');
            }
        }
        this.isUnitFocused = false;
        const focusedValue = Number(this.formattedTime[unit]);
        this.updateDescriptorFocusedValue(unit, focusedValue);
    }
    onUnitCellFocus(unit, value) {
        this.isUnitFocused = true;
        this.focusedUnit = unit;
        this.focusedValue = value;
        this.updateDescriptorFocusedValue(unit, value);
    }
    getElementList(unit) {
        var _a;
        return (_a = this.hostElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-element-list-id="${unit}"]`);
    }
    getElementContainer(unit, number) {
        var _a;
        return (_a = this.hostElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-element-container-id="${unit}-${number}"]`);
    }
    isElementVisible(element, container) {
        const elementRect = element.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();
        return (elementRect.top >= containerRect.top &&
            elementRect.bottom <= containerRect.bottom);
    }
    scrollElementIntoView(element, container, alignment) {
        const SCROLL_BUFFER = 1;
        const containerRect = container.getBoundingClientRect();
        const elementRect = element.getBoundingClientRect();
        if (alignment === 'end') {
            container.scrollTop +=
                elementRect.bottom - containerRect.bottom + SCROLL_BUFFER;
        }
        else {
            container.scrollTop +=
                elementRect.top - containerRect.top - SCROLL_BUFFER;
        }
    }
    updateFocusedValue(value) {
        const numberArray = this.getNumberArrayForUnit(this.focusedUnit);
        const maxValue = numberArray[numberArray.length - 1];
        const minValue = numberArray[0];
        if (value > maxValue) {
            value = minValue;
            this.focusScrollAlignment = 'start';
        }
        else if (value < minValue) {
            value = maxValue;
            this.focusScrollAlignment = 'end';
        }
        this.focusedValue = value;
    }
    setInitialFocusedValueAndUnit() {
        const firstVisibleDescriptor = this.timePickerDescriptors.find((descriptor) => !descriptor.hidden);
        if (!firstVisibleDescriptor) {
            return;
        }
        const selectedValue = Number(this.formattedTime[firstVisibleDescriptor.unit]);
        const isValidSelection = firstVisibleDescriptor.numberArray.includes(selectedValue);
        this.focusedValue = isValidSelection
            ? selectedValue
            : firstVisibleDescriptor.numberArray[0];
        this.focusedUnit = firstVisibleDescriptor.unit;
    }
    setupVisibilityObserver() {
        let dropdownElement = this.hostElement;
        while (dropdownElement && dropdownElement.tagName !== 'IX-DROPDOWN') {
            dropdownElement = dropdownElement.parentElement;
        }
        if (!dropdownElement) {
            return;
        }
        this.visibilityObserver = new MutationObserver((mutations) => this.mutationObserverCallback(mutations));
        this.visibilityObserver.observe(dropdownElement, {
            attributes: true,
            attributeFilter: ['class', 'style'],
        });
    }
    mutationObserverCallback(mutations) {
        for (const mutation of mutations) {
            if (mutation.type !== 'attributes') {
                continue;
            }
            const dropdown = mutation.target;
            if (!dropdown.classList.contains('show')) {
                // keep picker in sync with input
                if (this.time) {
                    const timeFormat = datetime.DateTime.fromFormat(this.time, this.format);
                    if (timeFormat.isValid) {
                        this._time = datetime.DateTime.fromFormat(this.time, this.format);
                        this.setInitialFocusedValueAndUnit();
                    }
                }
                continue;
            }
            const elementsReady = this.areElementsRendered();
            if (!elementsReady) {
                continue;
            }
            this.updateScrollPositions();
        }
    }
    areElementsRendered() {
        var _a;
        const elementLists = (_a = this.hostElement.shadowRoot) === null || _a === void 0 ? void 0 : _a.querySelectorAll('.element-list');
        if (!elementLists || elementLists.length === 0) {
            return false;
        }
        return Array.from(elementLists).some((list) => list.offsetHeight > 0);
    }
    getFormattedTime() {
        if (!this._time) {
            return FORMATTED_TIME_EMPTY;
        }
        return {
            hour: this.timeRef !== undefined
                ? this._time.toFormat('h')
                : this._time.toFormat('H'),
            minute: this._time.toFormat('m'),
            second: this._time.toFormat('s'),
            millisecond: this._time.toFormat('S'),
        };
    }
    timeUpdate(unit, value) {
        let maxValue = datetime.DateTime.now().endOf('day').get(unit);
        if (unit === 'hour') {
            if (this.timeRef === 'PM') {
                // 12 PM should remain 12, other PM hours add 12
                value = value === 12 ? 12 : value + 12;
            }
            else if (this.timeRef === 'AM') {
                // 12 AM should be 0, other AM hours remain as is
                value = value === 12 ? 0 : value;
                maxValue = 12;
            }
        }
        if (value > maxValue) {
            value = maxValue;
        }
        else if (value < 0) {
            value = 0;
        }
        if (!this._time) {
            this._time = datetime.DateTime.now().startOf('day');
        }
        this._time = this._time.set({
            [unit]: value,
        });
        return value;
    }
    changeTimeReference(newTimeRef) {
        if (this.timeRef === newTimeRef) {
            return;
        }
        if (!this._time) {
            this._time = datetime.DateTime.now().startOf('day');
        }
        this.timeRef = newTimeRef;
        const currentHour = this._time.hour;
        if (newTimeRef === 'PM' && currentHour < 12) {
            this._time = this._time.plus({ hours: 12 });
        }
        else if (newTimeRef === 'AM' && currentHour >= 12) {
            this._time = this._time.minus({ hours: 12 });
        }
        this.timeChange.emit(this._time.toFormat(this.format));
    }
    isFormat12Hour(format) {
        // Remove any text that's inside quotes (literal text in Luxon format strings)
        let cleanFormat = '';
        let inQuote = false;
        for (let i = 0; i < format.length; i++) {
            const char = format[i];
            if (char === "'") {
                inQuote = !inQuote;
            }
            else if (!inQuote) {
                cleanFormat += char;
            }
        }
        // Check for specific 12-hour format tokens
        // Case-sensitive matching to distinguish between 'h' and 'H'
        return /h|a|t/.test(cleanFormat);
    }
    setTimeRef() {
        const uses12HourFormat = this.isFormat12Hour(this.format);
        if (uses12HourFormat && this._time) {
            this.timeRef = this._time.hour >= 12 ? 'PM' : 'AM';
        }
        else {
            this.timeRef = undefined;
        }
    }
    getInitialFocusedValueForUnit(unit, numberArray) {
        const selectedValue = Number(this.formattedTime[unit]);
        return numberArray.includes(selectedValue) ? selectedValue : numberArray[0];
    }
    setTimePickerDescriptors() {
        let hourNumbers = [];
        let minuteNumbers = [];
        let secondNumbers = [];
        let millisecondsNumbers = [];
        if (this.timeRef !== undefined) {
            hourNumbers = Array.from({ length: Math.ceil(12 / this.hourInterval) }, (_, i) => i * this.hourInterval + 1).filter((hour) => hour <= 12);
        }
        else {
            hourNumbers = Array.from({ length: Math.ceil(24 / this.hourInterval) }, (_, i) => i * this.hourInterval);
        }
        minuteNumbers = Array.from({ length: Math.ceil(60 / this.minuteInterval) }, (_, i) => i * this.minuteInterval);
        secondNumbers = Array.from({ length: Math.ceil(60 / this.secondInterval) }, (_, i) => i * this.secondInterval);
        millisecondsNumbers = Array.from({ length: Math.ceil(1000 / this.millisecondInterval) }, (_, i) => i * this.millisecondInterval);
        this.timePickerDescriptors = [
            {
                unit: 'hour',
                header: this.i18nHourColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.hours.test(this.format),
                numberArray: hourNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('hour', hourNumbers),
            },
            {
                unit: 'minute',
                header: this.i18nMinuteColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.minutes.test(this.format),
                numberArray: minuteNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('minute', minuteNumbers),
            },
            {
                unit: 'second',
                header: this.i18nSecondColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.seconds.test(this.format),
                numberArray: secondNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('second', secondNumbers),
            },
            {
                unit: 'millisecond',
                header: this.i18nMillisecondColumnHeader,
                hidden: !LUXON_FORMAT_PATTERNS.milliseconds.test(this.format),
                numberArray: millisecondsNumbers,
                focusedValue: this.getInitialFocusedValueForUnit('millisecond', millisecondsNumbers),
            },
        ];
        this.timePickerDescriptors = this.timePickerDescriptors.filter((item) => !item.hidden);
    }
    getNumberArrayForUnit(unit) {
        const descriptor = this.timePickerDescriptors.find((descriptor) => descriptor.unit === unit);
        return descriptor ? descriptor.numberArray : [];
    }
    isSelected(unit, number) {
        return this.formattedTime[unit] === String(number);
    }
    select(unit, number) {
        if (this.isSelected(unit, number)) {
            return;
        }
        this.formattedTime = Object.assign(Object.assign({}, this.formattedTime), { [unit]: String(number) });
        this.timeUpdate(unit, number);
        this.elementListScrollToTop(unit, number, 'smooth');
        this.timeChange.emit(this._time.toFormat(this.format));
    }
    updateDescriptorFocusedValue(unit, value) {
        const descriptorIndex = this.timePickerDescriptors.findIndex((d) => d.unit === unit);
        if (descriptorIndex !== -1) {
            this.timePickerDescriptors = [
                ...this.timePickerDescriptors.slice(0, descriptorIndex),
                Object.assign(Object.assign({}, this.timePickerDescriptors[descriptorIndex]), { focusedValue: value }),
                ...this.timePickerDescriptors.slice(descriptorIndex + 1),
            ];
        }
    }
    elementListScrollToTop(unit, number, scrollBehaviour) {
        const elementList = this.getElementList(unit);
        const elementContainer = this.getElementContainer(unit, number);
        if (elementList && elementContainer) {
            const elementListHeight = elementList.clientHeight;
            const elementContainerHeight = elementContainer.clientHeight;
            // Offset which is used to adjust the scroll position to account for margins, elements being hidden, etc.
            let scrollPositionOffset = 11;
            if (this.hideHeader) {
                // 56 + 1 --> height of the header container and separator
                scrollPositionOffset -= 57;
            }
            const scrollPosition = elementContainer.offsetTop -
                elementListHeight / 2 +
                elementContainerHeight -
                scrollPositionOffset;
            elementList.scrollTo({
                top: scrollPosition,
                behavior: scrollBehaviour,
            });
        }
    }
    /**
     * Updates all scroll positions of the time picker elements
     * Updates only the elements that have changed if `formattedTimeOld` is provided
     */
    updateScrollPositions(formattedTimeOld = undefined) {
        for (const key in this.formattedTime) {
            const unitKey = key;
            if (!formattedTimeOld ||
                this.formattedTime[unitKey] !== formattedTimeOld[unitKey]) {
                this.elementListScrollToTop(unitKey, Number(this.formattedTime[unitKey]), 'instant');
            }
        }
    }
    formatUnitValue(unit, value) {
        if (unit === 'millisecond') {
            return value.toString().padStart(3, '0');
        }
        return value < 10 ? `0${value}` : value.toString();
    }
    getColumnSeparator(currentIndex) {
        if (currentIndex + 1 < this.timePickerDescriptors.length) {
            const nextUnit = this.timePickerDescriptors[currentIndex + 1].unit;
            return nextUnit === 'millisecond' ? '.' : ':';
        }
        return ':';
    }
    getElementContainerTabIndex(number, descriptorUnit) {
        const descriptor = this.timePickerDescriptors.find((d) => d.unit === descriptorUnit);
        if (number === (descriptor === null || descriptor === void 0 ? void 0 : descriptor.focusedValue)) {
            return '0';
        }
        return '-1';
    }
    render() {
        return (index.h(index.Host, { key: 'da95d86956db27851713b28d3727ee9d8e33f785' }, index.h("ix-date-time-card", { key: '5a8a88d641f859eaa2c1e1e2f7b699abd56f7f74', embedded: this.embedded, timePickerAppearance: true, corners: this.corners, hasFooter: !this.dateTimePickerAppearance, hideHeader: this.hideHeader }, index.h("div", { key: '85639253213bee998504da73ea4de0421cf146c3', class: "header", slot: "header" }, index.h("ix-typography", { key: '0a21cf47dd51eaf17c44271dbe4d63d909523055', format: "body" }, this.i18nHeader)), index.h("div", { key: '9d716194b4a37662e298e8d59c54142e78b9a6a0', class: "clock" }, this.timePickerDescriptors.map((descriptor, index$1) => (index.h("div", { class: "flex" }, index.h("div", { class: { columns: true, hidden: descriptor.hidden } }, index.h("div", { class: "column-header", title: descriptor.header }, descriptor.header), index.h("div", { "data-element-list-id": descriptor.unit, class: "element-list", tabIndex: -1 }, descriptor.numberArray.map((number) => {
            return (index.h("button", { "data-element-container-id": `${descriptor.unit}-${number}`, class: {
                    selected: this.isSelected(descriptor.unit, number),
                    'element-container': true,
                }, onClick: () => {
                    this.select(descriptor.unit, number);
                }, onFocus: () => this.onUnitCellFocus(descriptor.unit, number), onBlur: (e) => this.onUnitCellBlur(descriptor.unit, e), tabindex: this.getElementContainerTabIndex(number, descriptor.unit), "aria-label": `${descriptor.header}: ${number}` }, this.formatUnitValue(descriptor.unit, number)));
        }), index.h("div", { class: "element-list-padding" }))), index$1 !== this.timePickerDescriptors.length - 1 && (index.h("div", { class: {
                'column-separator': true,
                hidden: descriptor.hidden,
            } }, this.getColumnSeparator(index$1)))))), this.timeRef && (index.h("div", { key: 'b177d5ea743648618ab6b877f60a37b46d8a5fa5', class: "flex" }, index.h("div", { key: 'a714f52d250386088368bdfe5c28ad45a1fe2dd0', class: "column-separator" }), index.h("div", { key: 'c7730b336e486ec34fd23e293b8e70e309d153fe', class: "columns" }, index.h("div", { key: '56677d7c350e235777e5d06afd61b925934923d6', class: "column-header", title: "AM/PM" }), index.h("div", { key: '764fd7297bdafaa69d24c9a2655c9d4fa7a73966', class: "element-list", tabIndex: -1 }, index.h("button", { key: '6b7ddefac72c7d4a778e8de6c42fd593003f5e5f', "data-am-pm-id": "AM", class: {
                selected: this.timeRef === 'AM',
                'element-container': true,
            }, onClick: () => this.changeTimeReference('AM'), tabindex: "0", "aria-label": "AM" }, "AM"), index.h("button", { key: '75cccf55946da3b04faac2da0bd3c989b8f633a3', "data-am-pm-id": "PM", class: {
                selected: this.timeRef === 'PM',
                'element-container': true,
            }, onClick: () => this.changeTimeReference('PM'), tabindex: "0", "aria-label": "PM" }, "PM")))))), index.h("div", { key: 'e033175f6d142fd73661703c89c975874bc9d6be', class: {
                footer: true,
                'footer--compact': this.timePickerDescriptors.length <= 2,
            }, slot: "footer" }, index.h("ix-button", { key: '795d890b983737fd09cc7471c428266945062262', class: "confirm-button", onClick: () => {
                var _a;
                this.timeSelect.emit((_a = this._time) === null || _a === void 0 ? void 0 : _a.toFormat(this.format));
            } }, this.i18nConfirmTime)))));
    }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "format": ["watchFormatIntervalPropHandler"],
        "hourInterval": ["watchHourIntervalPropHandler"],
        "minuteInterval": ["watchMinuteIntervalPropHandler"],
        "secondInterval": ["watchSecondIntervalPropHandler"],
        "millisecondInterval": ["watchMillisecondIntervalPropHandler"],
        "time": ["watchTimePropHandler"],
        "_time": ["onTimeChange"]
    }; }
};
__decorate([
    listener.OnListener('keydown')
], TimePicker.prototype, "handleKeyDown", null);
TimePicker.style = timePickerCss;

exports.ix_time_picker = TimePicker;
//# sourceMappingURL=ix-time-picker.entry.cjs.js.map

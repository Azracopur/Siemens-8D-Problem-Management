"use client";
import { jsx } from 'react/jsx-runtime';
import React, { useRef, useCallback } from 'react';
import ReactDOMClient from 'react-dom/client';
import InternalIxTree from './internal-tree.js';

const IxTree = React.forwardRef((props, ref) => {
    const cachedRootNodes = useRef(new Map());
    const renderItem = useCallback((_, data, __, context, update) => {
        const treeItem = document.createElement('ix-tree-item');
        const rootNode = ReactDOMClient.createRoot(treeItem);
        treeItem.hasChildren = data.hasChildren;
        treeItem.context = context[data.id];
        if (props.renderItem) {
            rootNode.render(props.renderItem(data.data));
        }
        update((itemData, newContext) => {
            treeItem.context = newContext[itemData.id];
            treeItem.hasChildren = itemData.hasChildren;
            if (props.renderItem) {
                rootNode.render(props.renderItem(itemData.data));
            }
        });
        cachedRootNodes.current.set(treeItem, rootNode);
        return treeItem;
    }, []);
    return (jsx(InternalIxTree
    //@ts-expect-error ref exposed by the StencilComponent type
    , { 
        //@ts-expect-error ref exposed by the StencilComponent type
        ref: ref, ...props, renderItem: props.renderItem ? renderItem : undefined, onNodeRemoved: (removed) => {
            const { detail } = removed;
            detail.forEach((removedItemElement) => {
                if (cachedRootNodes.current.has(removedItemElement)) {
                    cachedRootNodes.current.get(removedItemElement)?.unmount();
                    cachedRootNodes.current.delete(removedItemElement);
                }
            });
        } }));
});

export { IxTree, IxTree as default };
//# sourceMappingURL=tree.js.map

'use strict';

var index = require('./index-C8Xo8L1k.js');
var floatingUi_dom = require('./floating-ui.dom-CMzYsRR7.js');
var findElement = require('./find-element-D7yD1Ukn.js');
var makeRef = require('./make-ref-BaH6_YJk.js');
var shadowDom = require('./shadow-dom-DT01VwcB.js');
var disposableEventListener = require('./disposable-event-listener-BALEIeXq.js');

const tooltipCss = ".dialog{margin:0;padding:0;border:none;max-width:18.25rem;width:-moz-max-content;width:max-content;background-color:transparent;overflow-wrap:break-word;box-shadow:none;overflow:visible}.tooltip-container{display:block;position:relative;width:auto;height:-moz-fit-content;height:fit-content;background:var(--theme-tootlip--background);color:var(--theme-color-std-text);padding:0.375rem 0.75rem;box-shadow:var(--theme-shadow-4);border-radius:0.25rem}.content-wrapper{overflow:auto}.tooltip-title{display:flex}.tooltip-title ::slotted(ix-icon){margin:0.125rem 0.25rem 0.125rem 0}.arrow,.arrow::before{position:absolute;width:12px;height:12px;background:inherit}.arrow{visibility:hidden}.arrow::before{visibility:visible;content:\"\";transform:rotate(45deg);background-color:var(--theme-tootlip--background)}";

const ARROW_OFFSET = -6;
const numberToPixel = (value) => value !== null ? `${value}px` : '';
let tooltipInstance = 0;
const Tooltip = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        /**
         * Define if the user can access the tooltip via mouse.
         */
        this.interactive = false;
        /**
         * Initial placement of the tooltip.
         * If the selected placement doesn't have enough space, the tooltip will be repositioned to another location.
         */
        this.placement = 'top';
        /** @internal */
        this.showDelay = 0;
        /** @internal */
        this.hideDelay = 50;
        /** @internal */
        this.animationFrame = false;
        this.visible = false;
        this.instance = tooltipInstance++;
        this.dialogRef = makeRef.makeRef();
    }
    get arrowElement() {
        return this.hostElement.shadowRoot.querySelector('.arrow');
    }
    /** @internal */
    async showTooltip(anchorElement) {
        this.clearTimeouts();
        if (this.showTooltipTimeout || this.visibleFor === anchorElement) {
            return;
        }
        const dialog = await this.dialogRef.waitForCurrent();
        this.showTooltipTimeout = setTimeout(() => {
            this.setAnchorElement(anchorElement);
            dialog.showPopover();
            this.applyTooltipPosition(anchorElement, dialog);
            this.registerTooltipListener(dialog);
        }, this.showDelay);
    }
    /** @internal */
    async hideTooltip(hideDelay = this.hideDelay) {
        this.clearTimeouts();
        if (this.hideTooltipTimeout || !this.visible) {
            return;
        }
        if (this.interactive && hideDelay === 50) {
            hideDelay = 150;
        }
        const dialog = await this.dialogRef.waitForCurrent();
        this.hideTooltipTimeout = setTimeout(() => {
            var _a, _b;
            this.setAnchorElement();
            dialog.hidePopover();
            (_a = this.disposeAutoUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
            (_b = this.disposeTooltipListener) === null || _b === void 0 ? void 0 : _b.call(this);
        }, hideDelay);
    }
    setAnchorElement(anchorElement) {
        if (!anchorElement) {
            this.visibleFor = undefined;
            this.visible = false;
        }
        else {
            this.visibleFor = anchorElement;
            this.visible = true;
        }
    }
    computeArrowPosition({ placement, middlewareData, }) {
        let { x, y } = middlewareData.arrow;
        const resetPosition = {
            top: 'unset',
            right: 'unset',
            bottom: 'unset',
            left: 'unset',
        };
        if (placement.startsWith('top')) {
            return Object.assign(Object.assign({}, resetPosition), { left: numberToPixel(x), bottom: numberToPixel(ARROW_OFFSET) });
        }
        if (placement.startsWith('right')) {
            return Object.assign(Object.assign({}, resetPosition), { left: numberToPixel(ARROW_OFFSET), top: numberToPixel(y) });
        }
        if (placement.startsWith('bottom')) {
            return Object.assign(Object.assign({}, resetPosition), { left: numberToPixel(x), top: numberToPixel(ARROW_OFFSET) });
        }
        if (placement.startsWith('left')) {
            return Object.assign(Object.assign({}, resetPosition), { right: numberToPixel(ARROW_OFFSET), top: numberToPixel(y) });
        }
    }
    async computeTooltipPosition(target, dialog) {
        return floatingUi_dom.computePosition(target, dialog, {
            strategy: 'fixed',
            placement: this.placement,
            middleware: [
                floatingUi_dom.shift(),
                floatingUi_dom.offset(12),
                floatingUi_dom.arrow({
                    element: this.arrowElement,
                }),
                floatingUi_dom.flip({
                    fallbackStrategy: 'initialPlacement',
                    fallbackAxisSideDirection: 'end',
                    padding: 10,
                }),
                floatingUi_dom.hide(),
            ],
        });
    }
    applyTooltipArrowPosition(computeResponse) {
        const arrowPosition = this.computeArrowPosition(computeResponse);
        Object.assign(this.arrowElement.style, arrowPosition);
    }
    async applyTooltipPosition(target, dialog) {
        if (!target) {
            return;
        }
        return new Promise((resolve) => {
            var _a;
            (_a = this.disposeAutoUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
            this.disposeAutoUpdate = floatingUi_dom.autoUpdate(target, dialog, async () => {
                var _a;
                const computeResponse = await this.computeTooltipPosition(target, dialog);
                const isHidden = (_a = computeResponse.middlewareData.hide) === null || _a === void 0 ? void 0 : _a.referenceHidden;
                if (isHidden) {
                    this.hideTooltip(0);
                    resolve(computeResponse);
                }
                if (computeResponse.middlewareData.arrow) {
                    this.applyTooltipArrowPosition(computeResponse);
                }
                const { x, y } = computeResponse;
                Object.assign(dialog.style, {
                    left: numberToPixel(x),
                    top: numberToPixel(y),
                });
                resolve(computeResponse);
            }, {
                ancestorResize: true,
                ancestorScroll: true,
                elementResize: true,
                animationFrame: this.animationFrame,
            });
        });
    }
    async queryAnchorElements() {
        if (this.for) {
            if (Array.isArray(this.for)) {
                return this.resolveElements(this.for);
            }
            else {
                return this.resolveElements([this.for]);
            }
        }
    }
    async resolveElements(references) {
        const elements = [];
        await Promise.all(references.map(async (reference) => {
            if (typeof reference === 'string') {
                const resolvedElements = await findElement.resolveSelector(reference, this.hostElement);
                if (resolvedElements) {
                    elements.push(...resolvedElements);
                }
            }
            else if (reference instanceof HTMLElement) {
                elements.push(reference);
            }
            else if (reference instanceof Promise) {
                elements.push(await reference);
            }
        }));
        return elements;
    }
    async registerTriggerListener() {
        var _a;
        (_a = this.disposeTriggerListener) === null || _a === void 0 ? void 0 : _a.call(this);
        const triggerElementList = await this.queryAnchorElements();
        if (!triggerElementList) {
            return;
        }
        const listeners = [];
        triggerElementList.forEach((element) => {
            listeners.push(...[
                {
                    element: element,
                    eventType: 'mouseenter',
                    callback: () => {
                        this.showTooltip(element);
                    },
                },
                {
                    element: element,
                    eventType: 'mouseleave',
                    callback: () => {
                        this.hideTooltip();
                    },
                },
                {
                    element: element,
                    eventType: 'focus',
                    callback: () => {
                        this.showTooltip(element);
                    },
                },
                {
                    element: element,
                    eventType: 'focusout',
                    callback: () => {
                        this.hideTooltip();
                    },
                },
            ]);
        });
        this.disposeTriggerListener = disposableEventListener.addDisposableEventListenerAsArray(listeners);
    }
    registerTooltipListener(dialog) {
        var _a;
        (_a = this.disposeTooltipListener) === null || _a === void 0 ? void 0 : _a.call(this);
        this.disposeTooltipListener = disposableEventListener.addDisposableEventListenerAsArray([
            {
                element: dialog,
                eventType: 'mouseenter',
                callback: () => {
                    if (this.interactive) {
                        this.clearHideTimeout();
                    }
                },
            },
            {
                element: dialog,
                eventType: 'focus',
                callback: () => {
                    if (this.interactive) {
                        this.clearHideTimeout();
                    }
                },
            },
            {
                element: dialog,
                eventType: 'mouseleave',
                callback: () => {
                    this.hideTooltip();
                },
            },
            {
                element: dialog,
                eventType: 'focusout',
                callback: () => {
                    this.hideTooltip();
                },
            },
            {
                element: dialog,
                eventType: 'click',
                callback: (event) => {
                    event.stopPropagation();
                },
            },
            {
                element: document,
                eventType: 'keydown',
                callback: (event) => {
                    if (event.key === 'Escape') {
                        this.hideTooltip();
                    }
                },
            },
        ]);
    }
    registerDomChangeListener() {
        const observer = new MutationObserver(() => {
            this.registerTriggerListener();
        });
        observer.observe(document.body, {
            attributes: true,
            attributeFilter: ['data-ix-tooltip'],
            childList: true,
            subtree: true,
        });
        this.disposeDomChangeListener = () => {
            observer.disconnect();
        };
    }
    clearHideTimeout() {
        clearTimeout(this.hideTooltipTimeout);
        this.hideTooltipTimeout = undefined;
    }
    clearShowTimeout() {
        clearTimeout(this.showTooltipTimeout);
        this.showTooltipTimeout = undefined;
    }
    clearTimeouts() {
        this.clearHideTimeout();
        this.clearShowTimeout();
    }
    componentWillLoad() {
        this.registerTriggerListener();
    }
    componentDidLoad() {
        this.registerDomChangeListener();
    }
    disconnectedCallback() {
        var _a, _b, _c, _d;
        this.clearTimeouts();
        (_a = this.disposeAutoUpdate) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this.disposeTriggerListener) === null || _b === void 0 ? void 0 : _b.call(this);
        (_c = this.disposeTooltipListener) === null || _c === void 0 ? void 0 : _c.call(this);
        (_d = this.disposeDomChangeListener) === null || _d === void 0 ? void 0 : _d.call(this);
    }
    handleTitleIconSlotChange(e) {
        const slot = e.target;
        const elements = shadowDom.getSlottedElements(slot);
        for (const element of elements) {
            if (element.tagName.toLowerCase() === 'ix-icon') {
                element.size = '16';
            }
        }
    }
    render() {
        return (index.h(index.Host, { key: '1176f8e37f2918a9708c8ccdbfc57f99508299f3', role: "tooltip", class: { visible: this.visible } }, index.h("dialog", { key: 'd4942b8d171e7e48defc505179d54ce09288c905', ref: this.dialogRef, id: 'tooltip-' + this.instance, class: "dialog", popover: "manual", inert: !this.visible }, index.h("div", { key: 'faef3b3e4b5a45ddb3872bd9d8ec1d6eb4a36221', class: "tooltip-container" }, index.h("div", { key: 'ce64bda5406c6a70ccddc41f0b4aa4010be1aca9', class: "content-wrapper" }, index.h("div", { key: '52a51ed895ea573d3e889e57a05f65193906492c', class: 'tooltip-title' }, index.h("slot", { key: 'b7965bd9963fcd789331e4c264e8d317bf7ed314', name: "title-icon", onSlotchange: (e) => this.handleTitleIconSlotChange(e) }), index.h("ix-typography", { key: 'b530dbbf13b752968decb45af3953f42e3a0c743', format: "h5" }, this.titleContent, index.h("slot", { key: 'c7152f89180904044dc26f996923cc5766ea1d0f', name: "title-content" }))), index.h("slot", { key: '3b00e9ed924a0c0d8527344c13a3c52a9afd0108' }), index.h("div", { key: '5401e6015c3a7ebf4749edc466ddca881e4f7d36', class: "arrow" }))))));
    }
    get hostElement() { return index.getElement(this); }
};
Tooltip.style = tooltipCss;

exports.ix_tooltip = Tooltip;
//# sourceMappingURL=ix-tooltip.entry.cjs.js.map

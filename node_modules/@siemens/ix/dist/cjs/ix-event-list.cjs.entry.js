'use strict';

var index = require('./index-C8Xo8L1k.js');
var mutationObserver = require('./mutation-observer-DE0YMfYu.js');
var rwd_util = require('./rwd.util-GTn-vgCJ.js');
var anime_esm = require('./anime.esm-AXTM6yn_.js');

const eventListCss = ":host{display:block;position:relative}:host *,:host *::after,:host *::before{box-sizing:border-box}:host ::-webkit-scrollbar-button{display:none}@-moz-document url-prefix(){:host *{scrollbar-color:var(--theme-scrollbar-thumb--background) var(--theme-scrollbar-track--background);scrollbar-width:thin}}:host{}:host ::-webkit-scrollbar{width:0.5rem;height:0.5rem}:host{}:host ::-webkit-scrollbar-track{border-radius:5px;background:var(--theme-scrollbar-track--background)}:host ::-webkit-scrollbar-track:hover{background:var(--theme-scrollbar-track--background--hover)}:host{}:host ::-webkit-scrollbar-thumb{border-radius:5px;background:var(--theme-scrollbar-thumb--background)}:host{}:host ::-webkit-scrollbar-thumb:hover{background:var(--theme-scrollbar-thumb--background--hover)}:host ::-webkit-scrollbar-corner{display:none}:host(.item-size-l){--event-list-item-height:6.5rem;--event-list-item-content-white-space:normal}:host(.compact){--event-list-item-border-radius:0;--event-list-item-margin-bottom:0}";

const EventList = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.mutationObserver = mutationObserver.createMutationObserver(this.onMutation.bind(this));
        /**
         * Determines the height of list items.
         * This can either be one of two predefined sizes ('S' or 'L') or an absolute pixel value.
         * In case a number is supplied it will get converted to rem internally.
         * Defaults to 'S'.
         */
        this.itemHeight = 'S';
        /**
         * Make event-list items more compact
         */
        this.compact = false;
        /**
         * Animate state change transitions. Defaults to 'false'.
         */
        this.animated = false;
        /**
         * Display a chevron icon in list items. Defaults to 'false'
         */
        this.chevron = false;
    }
    watchChevron(chevron) {
        this.handleChevron(chevron);
    }
    componentDidLoad() {
        if (this.animated) {
            this.triggerFadeIn();
        }
        if (!Number.isNaN(Number(this.itemHeight))) {
            const height = rwd_util.convertToRemString(this.itemHeight);
            this.hostElement
                .querySelectorAll('ix-event-list-item')
                .forEach((item) => {
                this.setCustomHeight(item, height);
            });
        }
        this.handleChevron(this.chevron);
        this.mutationObserver.observe(this.hostElement, {
            childList: true,
            subtree: true,
        });
    }
    onMutation(mutationRecords) {
        this.triggerFadeOut().then(() => {
            if (!Number.isNaN(Number(this.itemHeight))) {
                const height = rwd_util.convertToRemString(this.itemHeight);
                const eventListItems = this.findEventListItems(mutationRecords);
                eventListItems.forEach((item) => this.setCustomHeight(item, height));
            }
            this.handleChevron(this.chevron);
            this.triggerFadeIn();
        });
    }
    findEventListItems(mutationRecords) {
        const eventListItems = [];
        mutationRecords.forEach((mutation) => {
            if (mutation.type !== 'childList') {
                return;
            }
            mutation.addedNodes.forEach((node) => {
                const element = node;
                if (element.tagName === 'IX-EVENT-LIST-ITEM') {
                    eventListItems.push(element);
                }
            });
        });
        return eventListItems;
    }
    setCustomHeight(item, height) {
        item.style.setProperty('--event-list-item-height', height);
    }
    triggerFadeOut() {
        return new Promise((resolve) => {
            if (!this.animated) {
                resolve();
            }
            const listElement = this.hostElement.shadowRoot.querySelector('ul');
            anime_esm.animate(listElement, {
                opacity: [{ opacity: 1, easing: 'easeInSine' }, { opacity: 0 }],
                duration: EventList.fadeOutDuration,
                onComplete: () => {
                    resolve();
                },
            });
        });
    }
    triggerFadeIn() {
        if (!this.animated) {
            return;
        }
        const listItems = this.hostElement.querySelectorAll('ix-event-list-item');
        listItems.forEach((e, i) => {
            const delay = i * 80;
            const offset = delay / (delay + EventList.fadeInDuration);
            anime_esm.animate(e, {
                offset: offset,
                duration: EventList.fadeInDuration + delay,
                opacity: [0, 1],
                easing: 'easeInOutSine',
                delay: delay,
                autoplay: true,
            });
        });
    }
    handleChevron(chevron) {
        const listItems = this.hostElement.querySelectorAll('ix-event-list-item');
        listItems.forEach((e) => {
            if (chevron) {
                e.setAttribute('chevron', 'true');
            }
            else if (chevron !== undefined) {
                e.removeAttribute('chevron');
            }
        });
    }
    render() {
        return (index.h(index.Host, { key: '71648df2cdbbb1951fa970739cdf1a6f4bd1c40f', class: {
                'item-size-s': this.itemHeight === 'S',
                'item-size-l': this.itemHeight === 'L',
                compact: this.compact,
            } }, index.h("div", { key: 'ce46bd8d70b502d2dd19ffee75d2f3ae45e95d5a', role: "list" }, index.h("slot", { key: '016b05cd0e580af2e89232c3f4a0b5ebad8bda62' }))));
    }
    get hostElement() { return index.getElement(this); }
    static get watchers() { return {
        "chevron": ["watchChevron"]
    }; }
};
EventList.fadeOutDuration = 50;
EventList.fadeInDuration = 150;
EventList.style = eventListCss;

exports.ix_event_list = EventList;
//# sourceMappingURL=ix-event-list.entry.cjs.js.map
